\BOOKMARK [1][-]{section.1}{Introduction}{}% 1
\BOOKMARK [1][-]{section.2}{Implementing arbitrary lookup tables}{}% 2
\BOOKMARK [1][-]{section.3}{Using randomized constraints for key/value mappings}{}% 3
\BOOKMARK [1][-]{section.4}{From a sorted list to a lookup argument}{}% 4
\BOOKMARK [1][-]{section.5}{The final permutation check}{}% 5
\BOOKMARK [1][-]{section.6}{Efficiency Analysis}{}% 6
\BOOKMARK [1][-]{section.7}{Examples: XOR}{}% 7
\BOOKMARK [2][-]{subsection.7.1}{example: bit rotations on 32 bit integers}{section.7}% 8
\BOOKMARK [2][-]{subsection.7.2}{example: unsigned addition}{section.7}% 9
\BOOKMARK [2][-]{subsection.7.3}{example: Blake2s}{section.7}% 10
\BOOKMARK [1][-]{section.8}{RAM overview}{}% 11
\BOOKMARK [2][-]{subsubsection.8.0.1}{RAM memory access model}{section.8}% 12
\BOOKMARK [2][-]{subsection.8.1}{RAM consistency checks via reduced permutations}{section.8}% 13
\BOOKMARK [2][-]{subsection.8.2}{RAM consistency checks via copy constraints}{section.8}% 14
\BOOKMARK [2][-]{subsection.8.3}{RAM consistency checks via range checks}{section.8}% 15
\BOOKMARK [2][-]{subsection.8.4}{Assigning RAM sets to program memory}{section.8}% 16
\BOOKMARK [2][-]{subsection.8.5}{Permutation argument to map A to B}{section.8}% 17
\BOOKMARK [2][-]{subsection.8.6}{Transition constraints over set B}{section.8}% 18
\BOOKMARK [2][-]{subsection.8.7}{Initializing memory}{section.8}% 19
\BOOKMARK [2][-]{subsection.8.8}{Efficiency analysis}{section.8}% 20
\BOOKMARK [1][-]{section.9}{Scheme without masks}{}% 21
