% !tex ts-program = pdflatex
% !tex encoding = utf-8 unicode

% this is a simple template for a latex document using the "article" class.
% see "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={3.0},
]{doclicense}

\usepackage[utf8]{inputenc} % set input encoding (not needed with xelatex)
\usepackage[strict]{changepage}
    
    %%% examples of article customizations
    % these packages are optional, depending whether you want the features they provide.
    % see the latex companion or other references for full information.
    
    
    %%% page dimensions
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (us) or a5paper or....
    % \geometry{margin=2in} % for example, change the margins to 2 inches all round
    % \geometry{landscape} % set up the page for landscape
    %   read geometry.pdf for detailed page layout information
 \usepackage{numdef}
   
\usepackage{graphicx} % support the \includegraphics command and options
    % some of the article customisations are relevant for this class
\usepackage{amsmath,amsthm}
\usepackage{amsfonts} % math fonts such as \mathbb{}
\usepackage{amssymb} % \therefore
\usepackage{hyperref}
\usepackage{cryptocode}
\usepackage{framed} 
    % \usepackage[parfill]{parskip} % activate to begin paragraphs with an empty line rather than an indent
    
    %%% packages
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. Enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
    % % these packages are all incorporated in the memoir class to one degree or another...
\usepackage{mathrsfs}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{adjustbox}

\usepackage{pgfplots}

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
  
    %%% headers & footers
\usepackage{fancyhdr} % this should be set after setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}
    
    
    %%% section title appearance
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (see the fntguide.pdf for font help)
    % (this matches context defaults)
    
    %%% toc (table of contents) appearance
\usepackage[nottoc,notlof,notlot]{tocbibind} % put the bibliography in the toc
\usepackage[titles,subfigure]{tocloft} % alter the style of the table of contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % no bold!

    %%% end article customizations
    \newcommand{\code}[1]{\texttt{#1}}
\newcommand\tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut
\newcommand{\bgamma}{\boldsymbol{\gamma}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
%%% the "real" document content comes below...
%\newcommand{\papertitle}{$\mathsf{Maitreya}$: Improved Prover Efficiency in Fully Succinct Universal zk-SNARKs through Permutation Arguments for Multiplicative Subgroups}
\newcommand{\papertitle}{$\mathbf{PLONK}$ with lookups (draft)}
%\newcommand{\authorname}}
\newcommand{\company}{}
\title{ \bf \papertitle \\[0.72cm]}
 \author{ Ariel Gabizon\\ \tt{Aztec}  \and Zachary J. Williamson\\ \tt{Aztec}}
% 	\large{\authorname} \\[0.5cm] \large{\company}
% 	\\ {DRAFT}
%}
    %\date{} % activate to display a given date or no date (if empty),
  
           % otherwise the current date is printed 
	
\ProvidesPackage{numdef}

%% Ariel Macros:
\num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
\newcommand{\Gi}{\ensuremath{{\mathbb G}_i}\xspace}
%\newcommand{\G}{\ensuremath{{\mathbb G}}\xspace}
\newcommand{\Gstar}{\ensuremath{{\mathbb G}^*}\xspace}
\newcommand{\x}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\z}{\ensuremath{\mathbf{z}}\xspace}
\newcommand{\X}{\ensuremath{\mathbf{X}}\xspace}

\num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0} }\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0} }\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}
\newcommand{\prvperm}{\ensuremath{\mathrm{P_{\mathsf{\sigma}}}}\xspace}
\newcommand{\verperm}{\ensuremath{\mathrm{V_{\mathsf{\sigma}}}}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{\mathbb F}\xspace}
\newcommand{\Fstar}{\ensuremath{\mathbb F^*}\xspace}

\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}

\newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
\newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
\newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{(#1)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\adv}{\ensuremath{\mathcal A}\xspace}
\newcommand{\advprime}{\ensuremath{{\mathcal A}'}\xspace}
\newcommand{\extprime}{\ensuremath{E'}\xspace}
\newcommand{\advrand}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
\num\newcommand{\srs1}{\ensuremath{\mathsf{srs_1}}\xspace}
\num\newcommand{\srs2}{\ensuremath{\mathsf{srs_2}}\xspace}
\num\newcommand{\srs0}{\ensuremath{\mathsf{srs}}\xspace}
\newcommand{\srsi}{\ensuremath{\mathsf{srs_i}}\xspace}
\newcommand{\com}{\ensuremath{\mathsf{com}}\xspace}
\newcommand{\comperm}{\ensuremath{\mathsf{com_{\sigma}}}\xspace}
\newcommand{\cm}{\ensuremath{\mathsf{cm}}\xspace}
\newcommand{\cmsig}{\ensuremath{\mathsf{cm_\sigma}}\xspace}
\newcommand{\open}{\ensuremath{\mathsf{open}}\xspace}
\newcommand{\openperm}{\ensuremath{\mathsf{open_{\sigma}}}\xspace}
\newcommand{\sigof}[1]{\ensuremath{\sigma(#1)}\xspace}
\newcommand{\proverexp}{\ensuremath{\mathsf{e}}\xspace}
\newcommand{\reducedelems}{\ensuremath{\mathsf{r}}\xspace}

\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\renewcommand{\deg}{\ensuremath{\mathrm{deg}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}
\newcommand{\abase}{\ensuremath{A_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\bbase}{\ensuremath{B_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\cbase}{\ensuremath{C_{\mathrm{\mathbf{0}}}}\xspace}

\newcommand{\amid}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\bmid}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\cmid}{\ensuremath{C_{\mathrm{mid}}}\xspace}

\newcommand{\negl}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2
\newcommand{\nilp}{\ensuremath{\mathscr N}\xspace}
\newcommand{\groupgen}{\ensuremath{\mathscr G}\xspace}
\newcommand{\qap}{\ensuremath{\mathscr Q}\xspace}
\newcommand{\polprot}[4]{$(#1,#2,#3,#4)$-polynomial protocol}
\newcommand{\rangedprot}[5]{$#5$-ranged $(#1,#2,#3,#4)$-polynomial protocol}

\newcommand{\rej}{\ensuremath{\mathsf{rej}}\xspace}
\newcommand{\acc}{\ensuremath{\mathsf{acc}}\xspace}
\newcommand{\res}{\ensuremath{\mathsf{res}}\xspace}
\newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
 \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\mathsf{comm}_{#1}}\xspace}
 \newcommand{\defeq}{:=}

\newcommand{\B}{\ensuremath{\vec{B}}\xspace}
\newcommand{\dom}{\ensuremath{H}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\Btwo}{\ensuremath{\vec{B_2}}\xspace}
\newcommand{\treevecsimp}{\ensuremath{(\tau,\rho_A,\rho_A \rho_B,\rho_A\alpha_A,\rho_A\rho_B\alpha_B, \rho_A\rho_B\alpha_C,\beta,\beta\gamma)}\xspace}% The sets of elements used in simplifed relation tree in main text body
\newcommand{\rcptc}{random-coefficient subprotocol\xspace}
\newcommand{\rcptcparams}[2]{\ensuremath{\mathrm{RCPC}(#1,#2)}\xspace}
\newcommand{\verifyrcptcparams}[2]{\ensuremath{\mathrm{\mathsf{verify}RCPC}(#1,#2)}\xspace}
\newcommand{\randadv}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
 \num\newcommand{\ex1}[1]{\ensuremath{ #1\cdot g_1}\xspace}
 \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
 \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
 \newcommand{\partition}{\ensuremath{{\mathcal T}}\xspace}
 \newcommand{\partof}[1]{\ensuremath{{\partition_{#1}}}\xspace}
\num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
\num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
 \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
 \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace} 
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace} 
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}
\newcommand{\trapdoor}{\ensuremath{r}}
\newcommand{\trapdoorext}{\ensuremath{r_{\mathrm{ext}}}\xspace}
\newcommand{\trapdoorsim}{\ensuremath{r_{\mathrm{sim}}}\xspace}
\renewcommand{\mod}{\ensuremath{\;\mathrm{mod}\;}}
\newcommand{\hsub}{\ensuremath{H^*}\xspace}
\num\newcommand{\enc1}[1]{\ensuremath{\left[#1\right]_1}\xspace}
\newcommand{\enci}[1]{\ensuremath{\left[#1\right]_i}\xspace}
\num\newcommand{\enc2}[1]{\ensuremath{\left[#1\right]_2}\xspace}
\newcommand{\gen}{\ensuremath{\mathsf{gen}}\xspace}
\newcommand{\prv}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\prvpoly}{\ensuremath{\mathrm{P_{\mathsf{poly}}}}\xspace}
\newcommand{\prvpc}{\ensuremath{\mathrm{P_{\mathsf{PC}}}}\xspace}
\newcommand{\verpoly}{\ensuremath{\mathrm{V_{\mathsf{poly}}}}\xspace}
\newcommand{\verpc}{\ensuremath{\mathrm{V_{\mathsf{PC}}}}\xspace}
\newcommand{\ideal}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\prf}{\ensuremath{\pi}\xspace}
\newcommand{\simprv}{\ensuremath{\mathrm{P^{sim}}}\xspace}

%\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
%\num\newcommand{\G0}{\ensuremath{\mathbf{G}}\xspace}
\newcommand{\GG}{\ensuremath{\mathbf{G^*}}\xspace}  % would have liked to call this G01 but problem with name
\num\newcommand{\g0}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\inst}{\ensuremath{\phi}\xspace}
\newcommand{\inp}{\ensuremath{\mathsf{x}}\xspace}
\newcommand{\wit}{\ensuremath{\omega}\xspace}
\newcommand{\ver}{\ensuremath{\mathsf{\mathbf{V}}}\xspace}
\newcommand{\per}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\sonic}{\ensuremath{\mathsf{Sonic}}\xspace}
\newcommand{\aurora}{\ensuremath{\mathsf{Aurora}}\xspace}
\newcommand{\auroralight}{\ensuremath{\mathsf{Auroralight}}\xspace}
\newcommand{\groth}{\ensuremath{\mathsf{Groth'16}}\xspace}
\newcommand{\kate}{\ensuremath{\mathsf{KZG}}\xspace}
\newcommand{\rel}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\ext}{\ensuremath{E}\xspace}
\newcommand{\params}{\ensuremath{\mathsf{params}_{\inst}}\xspace}
\newcommand{\protparams}{\ensuremath{\mathsf{params}_{\inst}^\advv}\xspace}
\num\newcommand{\p1}{\ensuremath{P_1}\xspace}
\newcommand{\advv}{\ensuremath{ {\mathcal A}^{\mathbf{*}}}\xspace} % the adversary that uses protocol adversary as black box
\newcommand{\crs}{\ensuremath{\sigma}\xspace}
%\num\newcommand{\crs1}{\ensuremath{\mathrm{\sigma}_1}\xspace}
%\num\newcommand{\crs2}{\ensuremath{\mathrm{\sigma}_2}\xspace}
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand{\hgen}{\ensuremath{\mathbf{g}}\xspace}
\renewcommand{\sim}{\ensuremath{\mathsf{sim}}\xspace}%the distribution of messages when \advv simulates message of \p1
\newcommand{\real}{\ensuremath{\mathsf{real}}\xspace}%the distribution of messages when \p1 is honest and \adv controls rest of players
 \newcommand{\koevec}[2]{\ensuremath{(1,#1,\ldots,#1^{#2},\alpha,\alpha #1,\ldots,\alpha #1^{#2})}\xspace}
\newcommand{\mida}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\midb}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\midc}{\ensuremath{C_{\mathrm{mid}}}\xspace}
\newcommand{\chal}{\ensuremath{\mathsf{challenge}}\xspace}
\newcommand{\attackparams}{\ensuremath{\mathsf{params^{pin}}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\attackdist}[2]{\ensuremath{AD_{#1}}\xspace}
\renewcommand{\neg}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\ro}{\ensuremath{{\mathcal R}}\xspace}
\newcommand{\elements}[1]{\ensuremath{\mathsf{elements}_{#1}}\xspace}
 \num\newcommand{\elmpowers1}[1]{\ensuremath{\mathrm{\mathsf{e}}^1_{#1}}\xspace}
 \num\newcommand{\elmpowers2}[1]{\ensuremath{\mathrm{\mathsf{e}}^2_{#1}}\xspace}
\newcommand{\elempowrs}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
 \newcommand{\secrets}{\ensuremath{\mathsf{secrets}}\xspace}
 \newcommand{\polysofdeg}[1]{\ensuremath{\F_{< #1}[X]}\xspace}
 \newcommand{\bivar}[1]{\ensuremath{\F_{< #1}[X,Y]}\xspace}
 \newcommand{\sig}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\prot}{\ensuremath{\mathscr{P}}\xspace}
 \newcommand{\PCscheme}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\protprime}{\ensuremath{\mathscr{P^*}}\xspace}
 \newcommand{\sigprv}{\ensuremath{\mathsf{P_{sc}}}\xspace}
 \newcommand{\sigver}{\ensuremath{\mathsf{V_{sc}}}\xspace}
 \newcommand{\sigpoly}{\ensuremath{\mathsf{S_{\sigma}}}\xspace}
 \newcommand{\idpoly}{\ensuremath{\mathsf{S_{ID}}}\xspace}
\newcommand{\idpolyevala}{\ensuremath{\mathsf{\bar{s}_{ID1}}}\xspace}
\newcommand{\sigpolyevala}{\ensuremath{\mathsf{\bar{s}_{\sigma1}}}\xspace}
\newcommand{\sigpolyevalb}{\ensuremath{\mathsf{\bar{s}_{\sigma2}}}\xspace}
\newcommand{\bctv}{\ensuremath{\mathsf{BCTV}}\xspace}
\newcommand{\PI}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\PIb}{\ensuremath{\mathsf{PI_B}}\xspace}
\newcommand{\PIc}{\ensuremath{\mathsf{PI_C}}\xspace}
\newcommand{\dl}[1]{\ensuremath{\widehat{#1}}\xspace}
\newcommand{\obgen}{\ensuremath{\mathcal O}\xspace}
\newcommand{\PC}{\ensuremath{\mathscr{P}}\xspace}
\newcommand{\permscheme}{\ensuremath{\sigma_\mathscr{P}}\xspace}

	
\newcommand{\selleft}{\ensuremath{\mathbf{q_L}}\xspace}
\newcommand{\selright}{\ensuremath{\mathbf{q_R}}\xspace}
\newcommand{\selout}{\ensuremath{\mathbf{q_O}}\xspace}
\newcommand{\selmult}{\ensuremath{\mathbf{q_M}}\xspace}
\newcommand{\selconst}{\ensuremath{\mathbf{q_C}}\xspace}
\newcommand{\selectors}{\ensuremath{\mathcal{Q}}\xspace}
\newcommand{\lvar}{\ensuremath{\mathbf{a}}\xspace}
\newcommand{\vars}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\rvar}{\ensuremath{\mathbf{b}}\xspace}
\newcommand{\ovar}{\ensuremath{\mathbf{c}}\xspace}
\newcommand{\pubvars}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\assignment}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\constsystem}{\ensuremath{\mathscr{C}}\xspace}
\newcommand{\relof}[1]{\ensuremath{\rel_{#1}}\xspace}
\newcommand{\pubinppoly}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\sumi}[1]{\sum_{i\in[#1]}}
\newcommand{\summ}[1]{\sum_{i\in[#1]}}
\newcommand{\sumj}[1]{\sum_{j\in[#1]}}
\newcommand{\ZeroH}{\ensuremath{Z_{H}} \xspace}
\newcommand{\lpoly}{\ensuremath{\mathsf{a}}\xspace}
\newcommand{\rpoly}{\ensuremath{\mathsf{b}}\xspace}
\newcommand{\opoly}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\idpermpoly}{\ensuremath{\mathsf{z}}\xspace}
\newcommand{\lagrangepoly}{\ensuremath{\mathsf{L}}\xspace}
\newcommand{\zeropoly}{\ensuremath{\mathsf{\ZeroH}}\xspace}
\newcommand{\selmultpoly}{\ensuremath{\mathsf{q_M}}\xspace}
\newcommand{\selleftpoly}{\ensuremath{\mathsf{q_L}}\xspace}
\newcommand{\selrightpoly}{\ensuremath{\mathsf{q_R}}\xspace}
\newcommand{\seloutpoly}{\ensuremath{\mathsf{q_O}}\xspace}
\newcommand{\selconstpoly}{\ensuremath{\mathsf{q_C}}\xspace}
\newcommand{\idcomm}{\ensuremath{[s_{\mathsf{ID1}}]_1}\xspace}
\newcommand{\sigcomma}{\ensuremath{[s_{\mathsf{\sigma1}}]_1}\xspace}
\newcommand{\sigcommb}{\ensuremath{[s_{\mathsf{\sigma2}}]_1}\xspace}
\newcommand{\sigcommc}{\ensuremath{[s_{\mathsf{\sigma3}}]_1}\xspace}
\newcommand{\selleftcomm}{\ensuremath{[q_\mathsf{L}]_1}\xspace}
\newcommand{\selrightcomm}{\ensuremath{[q_\mathsf{R}]_1}\xspace}
\newcommand{\seloutcomm}{\ensuremath{[q_\mathsf{O}]_1}\xspace}
\newcommand{\selconstcomm}{\ensuremath{[q_\mathsf{C}]_1}\xspace}
\newcommand{\selmultcomm}{\ensuremath{[q_\mathsf{M}]_1}\xspace}

\newcommand{\multlinecomment}[1]{\directlua{-- #1}}
    

\newtheorem{lemma}{Lemma}[section]
\newtheorem{thm}[lemma]{Theorem}
\newtheorem{dfn}[lemma]{Definition}
\newtheorem{remark}[lemma]{Remark}

\newtheorem{claim}[lemma]{Claim}
\newtheorem{corollary}[lemma]{Corollary}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\crct}{\ensuremath{\mathsf{C}}\xspace}
\newcommand{\A}{\mathcal{A}}
%\newcommand{\G}{\mathcal{G}}
\newcommand{\Gr}{\mathbb{G}}
%\newcommand{\com}{\textsf{com}}  Ariel defined equivalent that also works in math mode
\newcommand{\cgen}{\text{cgen}}
\newcommand{\poly}{\ensuremath{\mathsf{poly(\lambda)}}\xspace}
\newcommand{\snark}{\ensuremath{\mathsf{snark(\lambda)}}\xspace}
\newcommand{\grandprod}{\mathsf{prod}}
\newcommand{\perm}{\mathsf{perm}}
%\newcommand{\open}{\mathsf{open}}
\newcommand{\update}{\mathsf{update}}
\newcommand{\Prove}{\mathcal{P}}
\newcommand{\Verify}{\mathcal{V}}
\newcommand{\Extract}{\mathcal{E}}
\newcommand{\Simulate}{\mathcal{S}}
\newcommand{\Unique}{\mathcal{U}}
\newcommand{\Rpoly}{\R{\poly}}
\newcommand{\Ppoly}{\Prove{\poly}}
\newcommand{\Vpoly}{\Verify{\poly}}
\newcommand{\Psnark}{\Prove{\snark}}
\newcommand{\Vsnark}{\Verify{\snark}}
\newcommand{\Rprod}{\R{\grandprod}}
\newcommand{\Pprod}{\Prove{\grandprod}}
\newcommand{\Vprod}{\Verify{\grandprod}}
\newcommand{\Rperm}{\R{\perm}}
\newcommand{\Pperm}{\Prove{\perm}}
\newcommand{\Vperm}{\Verify{\perm}}
% \newcommand{\zw}[1]{{\textcolor{magenta}{Zac:#1}}}
% \newcommand{\ag}[1]{{\textcolor{blue}{\emph{Ariel:#1}}}}
\newcommand{\prob}{\ensuremath{\mathrm{Pr}}\xspace}
\newcommand{\extprot}{\ensuremath{E_{\prot}}\xspace}
\newcommand{\extpc}{\ensuremath{E_{\PCscheme}}\xspace}
\newcommand{\advpc}{\ensuremath{\mathcal A_{\PCscheme}}\xspace}
\newcommand{\advprot}{\ensuremath{\mathcal A_{\prot}}\xspace}
\newcommand{\protmany}{\ensuremath{ {\prot}_k}\xspace}

\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\plonk}{\ensuremath{\mathtt{PLONK}}\xspace}
\newcommand{\marlin}{\ensuremath{\mathsf{Marlin}}\xspace}
\newcommand{\fractal}{\ensuremath{\mathsf{Fractal}}\xspace}
\newcommand{\Rsnark}{\R{\snark}}
\begin{document}
    \maketitle


\section{Introduction}


We can use a reduced form of PLONK's permutation argument, to validate that two polynomials share the same roots. This in turn can be used to verify two polynomials share the same Lagrange coefficients. 

For two degree-n polynomials $A(X) = \sum_{i=1}^n a_iL_i(X), B(X) = \sum_{i=1}^n b_iL_i(X)$. Using a random challenge $\gamma \in \F_p$, we can verify that the two sets $\{a_1, \ldots, a_n \}, \{b_1, \ldots, b_n\}$ are identical:

$$ \prod_{i=1}^n \frac{(a_i + \gamma)}{(b_i + \gamma)} = 1$$

In addition, we can validate the correctness of subsets within larger sets. For $l$ subsets, we introduce a new challenge $\beta$ and two selector polynomials $q_1(X) = \sum_{i=1}^n \sigma_{1}(i)L_i(X), q_2(X) = \sum_{i=1}^n \sigma_{2}(i)L_i(X)$, where both $\sigma_{1}(i)$ and $\sigma_2(i)$ evaluate on $H$ to $l$ unique values. The modified permutation argument becomes

$$
\prod_{i=1}^n \frac{(a_i + \sigma_1(i)\beta + \gamma)}{(b_i + \sigma_2(i)\beta + \gamma)} = 1
$$

\section{Implementing arbitrary lookup tables}

Consider a PLONK circuit with a program width of $m$ and a depth of $n$. We can represent witnesses to the circuit's memory cells via $w_i$ for all $i \in [1, \ldots, mn]$.
\\
\\
We wish to prove that a subset of memory cells are copies of elements in a size $k$ precomputed lookup table. We represent table values via $t_i$ for all $i \in [1, \ldots, k]$.
\\
\\
To ensure that all polynomial identities are evaluated modulo the vanishing polynomial of a size-$n$ multiplicative subgroup $H$, we can split the lookup table into size-$n$ subsets. i.e. our PLONK circuit now has a \textit{table} width of $v$, where $vn >= k$.
\\
\\
To validate a sequence of lookups, the high level outline is as follows

\begin{enumerate}
	\item create a key/value mapping that maps an index in the lookup table to a value
	\item apply the key/value mapping to the table reads in program memory
	\item isolate \textit{unique} table reads in program memory
	\item isolate values from the lookup table $t$ that were copied into program memory
	\item validate a subset permutation on the set of unique table reads and the set of used table lookup values
\end{enumerate}

\section{Using randomized constraints for key/value mappings}

We can use randomized constraints to create key/value mappings for arbitrary combinations of keys and values. This is useful for situations where a key and a value require more values than the set of integers $[1, \ldots, p]$, where $p$ is the order of the circuit's native field arithmetic.
\\
\\
After committing to program memory values, the verifier generates a random challenge $\alpha$ and sends it to the prover. We can discriminate between $l$ distinct lookup tables using the $l$'th powers of $\alpha$.
\\
\\
The prover can now commit to a sorted list of table reads. We can define the number of table reads as $e = s n$, where $s <= w$. The set of table reads is represented via $\{ r_1, \ldots, r_e \}$, where each table read is a linear combination of two memory cells $w_1, w_2$, where $r = w_1 + \alpha w_2$. The specific mapping between memory cells and table read elements is described using $l$ randomized constraints, represented by identities $E_1, \ldots, E_l$.
\\
\\
We can now validate a permutation between the set of all table reads $$r_1, \ldots, r_e$$, and the set of values produced by applying $$E_1, \ldots, E_l$$ to every row in program memory.
\\
\\
\textit{example: XOR gates, width-4 circuit}. Consider the scenario where we wish to evaluate $a ^ b = c$, where $a, b, c$ are in the range $[0, \ldots, 255]$. All possible XOR combinations can be represented by $2^16$ values in a lookup table. For a row $i$ of program memory, the XOR constraint is
$$
E_1(\{w_{(i-1)m + 1}, \ldots, w_{im} \}) = w_{(i-1)m + 1} + 2^8 w_{(i-1)m + 2} + \alpha w_{(i-1)m + 3} + \beta + \gamma
$$

where $w_{(i-1)m + 1} = a$, $w_{(i-1)m + 2} = b$, $w_{(i-1)m + 3} = c$. Instead of directly mapping memory cells to values in $r_1, \ldots, r_e$, we map the output of the identities $E_1, \ldots, E_l$ to values in $r_1, \ldots, r_e$ instead.
\\
\\
We can use selector polynomials to toggle our randomized constraints on/off for a given row in program memory. This allows us to also mask out locations in program memory that are not table reads when required.
\\
\\
To validate the correctness of the values $\{ r_1, \ldots, r_e \}$, we validate that the following permutation holds:

$$
\frac{\prod_{i=1}^n (\sum_{j=1}^l E_j(\{ w_{(i-1)m + 1}, \ldots, w_{im}\}))}
{\prod_{i=1}^n \prod_{j=1}^s (r_{(i-1)s + j} + q_{(i-1)s + j}\beta + \gamma)}
$$

We can assume that, for any given $i \in [1, \ldots, n]$, only one randomized constraint will be active, which ensures that we are still evaluating a 'grand product'.
\\
\\
When the circuit is constructed, the number of table reads per sub-table will be known, which means that we can use a precomputed selector $q$ to map each element of $\{r_1, \ldots, r_n \}$ to their respective sub-table.
\\
\\
Finally, we should note that each identity can map more than one cell in program memory into the lookup read table. For example, we could index a range table using the following constraint:
$$
E_{range} = (w_1 + \beta^{range} + \gamma)(w_2 + \beta^{range} + \gamma)(w_3 + \beta^{range} + \gamma)
$$

Because we have introduced a selector polynomial to toggle each constraint, each identity can only contain (for a width 4 program) cubic terms, without increasing the degree of PLONK's quotient polynomial $T(X)$.

\section{From a sorted list to a lookup argument}

We are now at the stage where we can validate that all of a program's table reads have been mapped into the set of values $R = \{ r_1, \ldots, r_e \}$, split over $s$ degree-$n$ commitments.
\\
\\
We now need to provide the prover with a mechanism to remove duplicate elements. We can assume that the elements of $R$ are sorted in monotonically increasing order (for each subset). If this is not the case, our final permutation argument will be rejected by the verifier.
\\
\\
We introduce $s$ \textbf{mask} commitments, that contain elements $\{ m_1, \ldots, m_e \}$. Where all elements take boolean values. N.B. there seems like there should be a way to not need this mask thingy, but it's extremely cheap to commit to using a Lagrange-base SRS.
\\
\\
For a given mask element, if $m_i = 1$, the prover is making a claim that two adjacent values in $R$ are adjacent.
\\
\\
The verifier validate this by evaluating the following:
$$
m_i^2 - m_i = 0
$$

$$
(r_{i-1} - r_i)m_i = 0
$$

The latter identity always holds if $m_i = 0$. If $m_i = 1$, then $r_{i-1} = r_i$.
\\
\\
Note that this does not prevent the prover from \textit{not} masking duplicates. This is not necessary because the final permutation argument will fail if duplicates have not been removed.

\section{The final permutation check}

We almost have a complete lookup argument. The final step is the validate that elements $\{r_1m_1, \ldots, r_em_e \}$ is a \textit{subset} of the lookup table values $\{ t_1, \ldots, t_k \}$.
\\
\\
We need to accommodate for situations where not all table elements have been read from in a given proof - a strict permutation won't suffice.
\\
\\
To this end, we introduce a second set of $l$ masking polynomials $y_1(X), \ldots, y_l(X)$, containing elements $y_1, \ldots, y_k$.
\\
\\
We use a transition constraint to validate that
$$
y_i^2 - y_i = 0
$$
We represent our lookup table via $l$ commitments to table keys, $\{tk_1(X), \ldots, tk_l(X)\}$, $l$ commitments to table values $\{ tv_1(X), \ldots, tv_l(X) \}$ and $l$ commitments to subtable indices $\{ts_1(X), \ldots, ts_l(X) \}$.
\\
\\
The final permutation check is the following:

$$
\frac{
\prod_{i=1}^n \prod_{j=1}^l \bigg( y_{(i-1)l + j}(tk_{(i-1)l + j} + \alpha tv_{(i-1)l + j} + \beta ts_{(i-1)l + j} + \gamma) + (1 - y_{(i-1)l + j}) \bigg)
}
{
{\prod_{i=1}^n \prod_{j=1}^s\bigg( (1 - m_{(i-1)s + j})(r_{(i-1)s + j} + q_{(i-1)s + j}\beta + \gamma) + m_{(i-1)s + j} \bigg)}
}
$$

\section{Efficiency Analysis}

Adding this lookup argument into PLONK incurs the following fixed overheads for the prover:

\begin{enumerate}
	\item Two new grand product polynomials, to validate the two permutations (TODO: can these be combined somehow without exploding T(X)?)
	\item A commitment to $M(X)$
	\item A commitment to $Y(X)$
\end{enumerate}

Assuming these are committed to using a Lagrange-base SRS, the number of scalar multiplications will be equal to the number of reads, for the grand product polynomials. Both $M(X)$ and $Y(X)$ can be committed to using group additions instead of group exponentiations, so their overall contribution to prover time is small.
\\
\\
We can also generously assume that less than $1/4$ of all memory cells will be table reads. This sets $s = 1$. Similarly, we can likely assume that the set of all lookup table values will be less than $n$, which sets $l = 1$.
\\
\\
The final number of group exponentiations required by the prover for each table read is $3$ - one to commit to $R(X)$, one for each new grand product polynomial.

\section{Examples: XOR}

We can perform a 32-bit XOR in 4 gates (using an 8bit xor and not the funky sparse bit trick), using a lookup table and one randomized constraint.

$$
\begin{array}{cccc}
a_0 & b_0 & c_0 & --- \\
a_1 & b_1 & c_1 & --- \\
a_2 & b_2 & c_2 & --- \\
a_3 & b_3 & c_3 & --- \\
\end{array}
$$

With the above structure, we can ensure that all of $a_i, b_i, c_i$ track accumulating sums instead of raw 8-bit values - the randomized constraint can extract the 8-bit slices from the differences between elements. This means we don't have to swap between 8-bit representations and native representations of 32 bit integers, which makes it much easier to combine different arithmetic operations.

Total cost is 4 gates and 4 table reads. The 4 reads contribute 12 scalar multiplications. A gate's base 'cost' is 11 scalar multiplications, making the 32-bit XOR cost approximately 5 gates.
\\
\\
The current best case is the quaternary XOR custom gate, which requires 17 gates. This yields a >3x speed increase.

\subsection{example: bit rotations on 32 bit integers}

Assume we have a 32-bit unsigned integer, represented using 1 memory cell with value $a$. We wish to evaluate a bit rotation by a fixed number of bits. E.g. $a >>> 5$.
\\
\\
Any rotation by an odd number of bits will 'slice' one 16-bit value in two. In this case into a 11-bit value $b_0$, a 16-bit value $b_1$ and a 5-bit value $b_2$. i.e.

$$a >>> 5 = b_0 + 2^{16 - 5}b_1 + 2^{32 - 5}b_2$$

We can now validate the following:

$b =  b_0 + 2^{16 - 5}b_1 + 2^{32 - 5}b_2$
$a = b_2 + 2^5b_0 + 2^16b_1$

This requires 3 table lookups, $b_0$ must come from an 11-bit range, $b_1$ from a 16-bit range, $b_2$ from a 5-bit range. Both of above conditions can be verified using a single gate (but would require the ability to validate 2 arithmetic statements per gate. Otherwise 2 gates).
\\
\\
Total cost is 1 gate and 3 reads, which is ~2 native gates.

\subsection{example: unsigned addition}

Let's say we wish to evaluate $a + b = c$. Instead of using a basic add gate, we can use a lookup to ensure that $c$ is within the range $[0, \ldots, 2^{32}]$. Specifically we validate:

$$a + b = c_0 + 2^{16}c_1 + 2^{32}c_2$$

We use a simple transition constraint to validate that $c_2 \in [0, 1]$. We use lookup table reads to validate that $c_0$ and $c_1$ are 16-bit values.
\\
\\
Like in the XOR and bit rotation case, we can represent $c$ via accumulating sums in program memory, instead of raw 16-bit slices.
\\
\\
Total cost is 1 gate and 2 reads.

\subsection{example: Blake2s}

The Blake2s round function applies the following operation to three 32-bit variables $a, b, c$, where $d$ is a constant rotation value:

$$
e = (a + b) ^ c >>> d
$$

By combining the above three sub-programs, we can evaluate this 'add xor rotate' operation in 4 gates and 4 table reads!
\\
\\
Layout in program memory is the following:
$$
\begin{array}{|c|c|c|c|}
(a+b)_0 & c_0 & e_0 & --- \\
(a+b)_1 & c_1 & e_1 & b \\
(a+b)_2 & c_2 & e_2 & (b + overflow) \\
(a+b)_3 & c_3 & e_3 & a \\
\end{array}
$$

Step 1: all values `a+b`, `c`, `e` track accumulating sums. So ${(a+b)}_3 = a + b \text{ mod } 2^{32}$.
\\
Step 2: we use a lookup table that combines an XOR with a bit rotation, instead of performing these in discrete steps.
\\
Step 3: use a transition constraint that validates
$$
{a+b}_3 = a + {b + overflow}
$$
\\
Step 4: use a transition constraint that validates 
$$
({b + overflow} - b)^2 - ({b + overlow} - b) = 0
$$

A Blake2s round consists of 4 of these, which is 16 gates and 16 table reads. 
\\
\\
The blake2s hash function requires 80 applications of this round function, which would be 1,280 gates and 1,280 table reads. The table reads would cost ~3,840 scalar multiplications, which is equivalent to ~350 native gates. So the total cost would be $\approx1,650$ 'gates'. Current best estimate with quaternary decomposition constraints is $\approx6,700$. R1CS requires $>20,000$.


\section{RAM overview}

The following describes a sub-protocol that emulates dynamic memory access within a PLONK circuit. Each RAM access has constant complexity and is updatable by the prover. The contrasts with the current PLONK memory model, which enables strict copy constraints between specific witnesses, that must be known at 'circuit construction time'.
\\
\\
A RAM 'triple' consists of the following three witnesses:

\begin{itemize}
	\item An index $s \in F_p$
	\item A value $v \in F_p$
	\item A timestamp $t \in F_p$
\end{itemize}

Timestamp is 'when' in the execution trace a RAM lookup occurs (e.g. 1st lookup is $t_1 = 1$, 2nd is $t_2 = 2$ etc).

\subsubsection{RAM memory access model}

We model our RAM as write-after-read. That every RAM read is followed by a RAM write into the same index. %We will use permutation arguments to validate the correctness of RAM accesses - permutations enable bijective mappings between sets, therefore multiple RAM reads cannot refer to the same
Under this model, we can enable dynamic RAM by performing a consistency check - that every when a value is written into a RAM index, the subsequent access into that index will return the same value.

\subsection{RAM consistency checks via reduced permutations}

We define three sets of RAM triples:

\begin{itemize}
	\item Set $A$: RAM triples sorted by timestamp
	\item Set $B$: RAM triples sorted by index, with triples of the same index sorted by timestamp
	\item Set $C$: the set of all RAM reads in program memory
\end{itemize}

Standard PLONK copy constraints are used to map between $A$ and $C$, as the locations of specific RAM accesses within a circuit are fixed.
\\
\\
The verifier generates two random challenges $(\alpha, \beta) \in \F_p$, where for set elements $a_i \in A$:

$$ a_i = t_{i} + \alpha \cdot s_{\sigma_t(i)} + \beta \cdot v_{\sigma_t(i)}$$

Here, $\sigma_t(i)$ is a prover-defined permutation that maps timestamp-ordered indices into index-ordered indices.
\\
\\
Similarly, for set elements $b_i \in B:$

$$b_i = t_{\sigma_s(i)} + \alpha \cdot s_i + \beta \cdot v_i $$
\\
\\
Where $\sigma_s(i)$ is a prover-defined permutation that maps index-ordered indices into timestamp-ordered indices.
\\
\\
A reduced permutation argument can be used to map between sets $A$ and $B$. The verifier uses a grand-product argument to validate that

$$
\prod_{i=1}^n \frac{(a_i + \gamma)}{(b_i + \gamma)}
$$

\subsection{RAM consistency checks via copy constraints}

In set $B$, the verifier can use regular transition constraints to validate that adjacent triples have monotonically increasing indices. Specifically

$$
(s_{i + 1} - s_i)^2 - (s_{i + 1} - s_i) = 0
$$

This requires every RAM entry has a read/write multiplicity of at least one. Dummy reads can be added into a circuit to enable this.
\\
\\
A regular PLONK copy constraint can be used to validate that, for every pair of RAM triples, the index and value fields are identical.

$$
\forall j \in [1, \ldots, \frac{n}{2}]: s_{2*j} = s_{2 * j + 1} \quad , \quad v_{2 * j} = v_{2 * j + 1}
$$

The final consistency check is to ensure that, for elements in $B$ that share the same index, the timestamps are monotonically increasing. This validates that adjacent RAM accesses share identical values. i.e. every RAM read into a given index returns the previously written value.

\subsection{RAM consistency checks via range checks}

In set $B$, the set of witnesses $u = (t_{i + 1} - t_i) \cdot (1 - (s_{i + 1} - s_i))$ must fall within the range $0, \ldots, n$. Adjacent $s$ indices are monotonically increasing by $0$ or $1$. i.e. if $s_{i + 1} \ne s_i$, $u = 0$.
\\
\\
If $s_{i + 1} = s_i$, $u = (t_{i + 1} - t_i)$. i.e. if $u >= 0$, adjacent timestamp fields are monotonically increasing. The reduced permutation check between $A$ and $B$ ensures that $u \ne 0$ when $s_{i + 1} = s_i$.
\\
\\
We can use our range protocol to validate that $u \in [0, \ldots, n]$.

\subsection{Assigning RAM sets to program memory}

For width-4 PLONK, a single row of program memory can contain two elements of set $A$. This is because we can add an implicit timestamp via selector polynomials. Layout in program memory is as follows:

$$
\begin{array}{|c|c|c|c|}
s_{\sigma_t(i)} & v_{\sigma_t(i)} & s_{\sigma_t(i + 1)} & v_{\sigma_t(i + 1)} \\
\ldots & \ldots & \ldots & \ldots \\
s_{\sigma_t(n-1)} & v_{\sigma_t(n - 1)} & s_{\sigma_t(n)} & v_{\sigma_t(n)} \\
\end{array}
$$

Set $B$ requires timestamps as explicit values in program memory, with one RAM entry occupying an entire row. Layout is as follows:

$$
\begin{array}{|c|c|c|c|}
t_{\sigma_s(i)} & s_i & v_i & --- \\
t_{\sigma_s(i+1)} & s_{i+1} & v_{i+1} & (t_{\sigma_s(i+1)} - t_{\sigma_s(i)}) \cdot (s_{i+1} - s_{i}) \\
\ldots & \ldots & \ldots & \ldots \\
t_{\sigma_s(n)} & s_n & v_n & (t_{\sigma_s(n)} - t_{\sigma_s(n-1)}) \cdot (s_{n} - s_{n-1}) \\
\end{array}
$$

Set $C$ will be dispersed across the remaining program memory cells. Strict copy constraints validate the mapping between $C$ and $A$, therefore set $C$ requires no explicit structure in program memory.

\subsection{Permutation argument to map $A$ to $B$}

To verify our reduced permutation argument, we need to selectively integrate a subset of all witnesses into a grand product argument. To this end, we defined two selector polynomials $Q_{ram1}(X), Q_{ram2}(X)$, that used to conditionally include product terms into a grand product argument.
\\
\\
We include additional selector polynomials $Q_{t1}(X), Q_{t2}(X)$, that inject an implicit timestamp value into our timestamp-ordered set $A$. The permutation argument is as follows:

$$
\begin{array}{c}
Z(Xw) \cdot \bigg(\begin{array}{c} Q_{ram1}(X)(Q_{t1}(X) + \alpha \cdot A(X) + \beta \cdot B(X) + \gamma)
\\
\cdot (Q_{t2}(X) + \alpha \cdot C(X) + \beta \cdot D(X))) + (1 - Q_{ram1}(X)) \end{array}\bigg)
\\ = \\
Z(X)\bigg(Q_{ram2}(X)(A(X) + \alpha \cdot B(X) + \beta \cdot C(X) + \gamma) + (1 - Q_{ram2}(X))\bigg) \text{ mod } Z_H(X)
\end{array}
$$

One advantage of this construction is that $Z(X)$ can be considered sparse - adjacent elements do not change if a row of program memory is not a member of $A$ or $B$. When computed using a Lagrange-base preprocessed SRS, a commitment to $Z(X)$ can be computed with $n$ multi-exponentiations.
\\
\\
The final check we require, is that $Z(1) = 1$. This can be validated by validating that $(Z(X) - 1) L_1(X) = 0 \text{ mod } Z_H(X)$.

\subsection{Initializing memory}

We can use regular arithmetic gates to initialize values in set $A$ to circuit-specific constants (e.g. $0$).

\subsection{Efficiency analysis}

A RAM lookup will add $6$ extra witnesses into program memory, across $1.5$ rows. The lookup witnesses themselves require two values in program memory (the index and the value). The range check on $u$ will require one further witness in program memory. This brings the overall cost of a RAM access to $2.25$ PLONK gates.

\section{Scheme without masks}


\paragraph{Notation}

Fix integers $n,d$ and vectors $a\in \F^n, t\in\ F^d$.
We will (ab)use the notation $a\subset t$ to mean $\sett{a_i}{i\in [n]}\subset \sett{t_i}{i\in [d]}$.

When $a\subset t$ , we say that $a$ is \emph{sorted by $t$} to mean that values appear in the same order in $a$ as they do in $t$. Formally, for any $i<i'\in [n]$ such that $a_i\neq a_{i'}$, if $j,j'\in [d]$ are such that $t_{j} = a_i, t_{j'} =a_{i'}$ then $j<j'$.

Now, given $t\in \F^d, a\in \F^n, s\in \F^{n+d}$, define bi-variate polynomials $F,G$ as 
\[F(\beta,\gamma) \defeq (1+\beta)^n\cdot \prod_{i\in [n]} (\gamma + a_i) \prod_{i\in [d-1]} (\gamma(1+\beta) + t_i + \beta t_{i+1})\]
                                  
\[G(\beta,\gamma) \defeq \prod_{i\in [n+d-1]} \left( \gamma(1+\beta) + s_i + \beta s_{i+1} \right)\]
we have
\begin{claim}\label{clm:main_lookup}

 $F\equiv G$ if and only if 
 \begin{enumerate}
  \item $a \subset t$, and 
  \item $s$ is $(a,t)$ sorted by $t$. 
 \end{enumerate}

\end{claim}
\begin{proof}
 We first write $f,g$ as elements of $\F(\beta)[\gamma]$ while taking out a $(1+\beta)$ factor as follows.
\[F(\beta,\gamma) = (1+\beta)^{n+d-1}\cdot \prod_{i\in [n]} (\gamma + a_i) \prod_{i\in [d-1]} \left(\gamma + (t_i + \beta t_{i+1})/(1+\beta)\right)\]
                                  
\[G(\beta,\gamma)  = (1+\beta)^{n+d-1} \prod_{i\in [n+d-1]} \left( \gamma+ (s_i + \beta s_{i+1})/(1+\beta) \right)\]
 
 
 Suppose that $a\subset t$ and $s\in \F^{n+d}$ is $(a,t)$ sorted by $t$.

 Then for each $j\in [d-1]$, there is an index $i\in [n+d-1]$ where, such that
 $ (t_j,t_{j+1})=(s_i,s_{i+1})$.
 The corresponding factors in $F,G$ are equal. That is,
 \[(\gamma + (t_i + \beta t_{i+1})/(1+\beta)) = (\gamma + (t_i + \beta t_{i+1})/(1+\beta))\]
 
 
 
 For the other direction, assume $F\equiv G$ as polynomials in $\F[\beta,\gamma]$
 Then $F\equiv G$ also as elements of $\F(\beta)[\gamma]$.
 Since $\F(\beta)[\gamma]$ is a unique factorization domain, we know that the linear factors of $F,G$, as written above must be equal.
 Thus, for each $i\in [d-1]$, $G$ must have a factor equal to $(\gamma + (t_i + \beta t_{i+1})/(1+\beta))$.
 In other words, for some $j\in [n+d-1]$, 
 \[\gamma + (t_i + \beta t_{i+1})/(1+\beta)= \gamma+ (s_j + \beta s_{j+1})/(1+\beta),\]
 which implies $t_i + \beta t_{i+1}= s_j + \beta s_{j+1}$, and therefore $t_i= s_j, t_{i+1}=s_{j+1}$.
 Call $P\subset [n+d-1]$ the set of these $d-1$ indices $j$.
 For any other index $j\in [n+d-1]\setminus P$, there must be a factor ``coming from $a$'' in $F$ that equals the corresponding factor in $G$. More precisely, for such $j$ there exists $i\in [n]$ such that
 \[\gamma + a_i = \gamma+ (s_j + \beta s_{j+1})/(1+\beta),\]
 or equivalently
 \[a_i+ \beta a_i = s_j + \beta s_{j+1}\]
 which implies
 $a_i= s_j=s_{j+1}$.
 
 Thus, we know that whenever consecutive values in $s$ are different, they are exactly equal to two consecutive values in $t$, and all values of $a$ are values of $t$.
 
 \end{proof}
 
 Claim \ref{clm:main_lookup} motivates the following protocol.
 Let $H=\set{\hgen,\ldots,\hgen^{n+d}}$, $H_1\defeq \set{\hgen,\ldots,\hgen^n}, H_2 \defeq \set{\hgen^{n+1},\ldots\hgen^{n+d}}$
 \paragraph{Preprocessed polynomials:}
The polynomial $t \in \polysofdeg{d}$  describing the lookup values .


\paragraph{Inputs: $f\in \polysofdeg{n}$}
\paragraph{Protocol:}
\begin{enumerate}
 \item \prvpoly computes a polynomial $s\in \polysofdeg{n+d}$ that, identifying polynomials with vectors in $\F^{n+d}$ according to their values on $H$, is $(f,t)$ sorted by $t$.
 \item \prvpoly sends $s$ to \ideal.
 \item \verpoly chooses random $\beta,\gamma \in \F$ and sends them to \prvpoly.
 \item \prvpoly computes a polynomial $Z\in \polysofdeg{n+d}$ that aggregates the value $F(\beta,\gamma)/G(\beta,\gamma)$ where $F,G$ are as described above. Specifically, we let
\begin{enumerate}
 \item  $Z(\hgen) = 1$,
\item $Z(\hgen^i)=\prod_{1\leq j<i} (\gamma + f(\hgen^j))/(\gamma(1+\beta) + s(\hgen^j) + \beta s(\hgen^{j+1}))$, for $2\leq i \leq n+1$
\item \[Z(\hgen^{n+i})= \prod_{j\in [n]} (\gamma + f_j)\cdot \prod_{1\leq j < i} (\gamma(1+\beta) t_j + \beta t_{j+1})/\left(\prod_{1\leq j < n+i} (\gamma(1+\beta) s_j + \beta s_{j+1})\right).\]
 and
\end{enumerate}
 \item \prvpoly sends $Z$ to \ideal.
 \item \verpoly checks that $Z$ is of the form described similarly to the PLONK perm argument and
 that $Z(\hgen^{n+d})=1$.
 (TODO:write exact ver equations)
%  \begin{enumerate}
%   \item $L_1(a) (Z(a)-1) =0$.
%   \item $Z(a)f'(a) = g'(a)Z(a\cdot \hgen)$.
%  \end{enumerate}
 and outputs \acc iff all checks hold.
\end{enumerate}
\begin{lemma}\label{lem:lookupprot}
 Suppose that $\sett{f(\hgen^i)}{i\in [n]}$ is not contained in  \sett{t(\hgen^i}{i\in [d]}.
 Then for any strategy of \adv playing the role of \prvpoly in the above protocol, the probability that
 \verpoly accepts is \negl.
\end{lemma}
\begin{proof}
 Using Claim \ref{clm:main_lookup} we know that when $f$'s range is not contained in $t$'s for any choice of $s$ sent by \prvpoly the polynomials $F(\beta,\gamma), G(\beta,\gamma)$ are different.
 From the SZ lemma e.w.p \negl \verpoly chooses $\beta,\gamma$ such that $F(\beta,\gamma)\neq G(\beta,\gamma)$. In this case we have $Z(\hgen^{n+d})\neq 1$ which means \verpoly rejects.
\end{proof}



\end{document}


