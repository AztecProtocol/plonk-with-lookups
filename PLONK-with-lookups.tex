% !tex ts-program = pdflatex
% !tex encoding = utf-8 unicode

% this is a simple template for a latex document using the "article" class.
% see "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={3.0},
]{doclicense}

\usepackage[utf8]{inputenc} % set input encoding (not needed with xelatex)
\usepackage[strict]{changepage}
    
    %%% examples of article customizations
    % these packages are optional, depending whether you want the features they provide.
    % see the latex companion or other references for full information.
    
    
    %%% page dimensions
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (us) or a5paper or....
    % \geometry{margin=2in} % for example, change the margins to 2 inches all round
    % \geometry{landscape} % set up the page for landscape
    %   read geometry.pdf for detailed page layout information
 \usepackage{numdef}
   
\usepackage{graphicx} % support the \includegraphics command and options
    % some of the article customisations are relevant for this class
\usepackage{amsmath,amsthm}
\usepackage{amsfonts} % math fonts such as \mathbb{}
\usepackage{amssymb} % \therefore
\usepackage{hyperref}
\usepackage{cryptocode}
\usepackage{framed} 
    % \usepackage[parfill]{parskip} % activate to begin paragraphs with an empty line rather than an indent
    
    %%% packages
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. Enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
    % % these packages are all incorporated in the memoir class to one degree or another...
\usepackage{mathrsfs}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{adjustbox}

\usepackage{pgfplots}

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
  
    %%% headers & footers
\usepackage{fancyhdr} % this should be set after setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}
    
    
    %%% section title appearance
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (see the fntguide.pdf for font help)
    % (this matches context defaults)
    
    %%% toc (table of contents) appearance
\usepackage[nottoc,notlof,notlot]{tocbibind} % put the bibliography in the toc
\usepackage[titles,subfigure]{tocloft} % alter the style of the table of contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % no bold!

    %%% end article customizations
    \newcommand{\code}[1]{\texttt{#1}}
\newcommand\tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut
\newcommand{\bgamma}{\boldsymbol{\gamma}}
\newcommand{\bsigma}{\boldsymbol{\sigma}}
%%% the "real" document content comes below...
%\newcommand{\papertitle}{$\mathsf{Maitreya}$: Improved Prover Efficiency in Fully Succinct Universal zk-SNARKs through Permutation Arguments for Multiplicative Subgroups}
\newcommand{\papertitle}{${ \mathpgoth{\Large plookup}}$: A simplified polynomial protocol for lookup tables}
%\newcommand{\authorname}}
\newcommand{\company}{}
\title{ \bf \papertitle \\[0.72cm]}
 \author{ Ariel Gabizon\\ \tt{Aztec}  \and Zachary J. Williamson\\ \tt{Aztec}}
% 	\large{\authorname} \\[0.5cm] \large{\company}
% 	\\ {DRAFT}
%}
    %\date{} % activate to display a given date or no date (if empty),
  
           % otherwise the current date is printed 
	
\ProvidesPackage{numdef}
\newcommand{\alphabet}{abcdefghijklmnopqrs\/tuvwxyz}
\newcommand{\Alphabet}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}

\DeclareMathAlphabet{\mathpgoth}{OT1}{pgoth}{m}{n}
\DeclareMathAlphabet{\mathesstixfrak}{U}{esstixfrak}{m}{n}
\DeclareMathAlphabet{\mathboondoxfrak}{U}{BOONDOX-frak}{m}{n}

%% Ariel Macros:
\num\newcommand{\G1}{\ensuremath{{\mathbb G}_1}\xspace}
\newcommand{\Gi}{\ensuremath{{\mathbb G}_i}\xspace}
%\newcommand{\G}{\ensuremath{{\mathbb G}}\xspace}
\newcommand{\Gstar}{\ensuremath{{\mathbb G}^*}\xspace}
\newcommand{\x}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\z}{\ensuremath{\mathbf{z}}\xspace}
% \newcommand{\X}{\ensuremath{\mathbf{X}}\xspace}

\num\newcommand{\G2}{\ensuremath{{\mathbb G}_2}\xspace}
%\num\newcommand{\G11}{\ensuremath{\G1\setminus \set{0} }\xspace}
%\num\newcommand{\G21}{\ensuremath{\G2\setminus \set{0} }\xspace}
\newcommand{\grouppair}{\ensuremath{G^*}\xspace}
\newcommand{\prvperm}{\ensuremath{\mathrm{P_{\mathsf{\sigma}}}}\xspace}
\newcommand{\verperm}{\ensuremath{\mathrm{V_{\mathsf{\sigma}}}}\xspace}

\newcommand{\Gt}{\ensuremath{{\mathbb G}_t}\xspace}
\newcommand{\F}{\ensuremath{\mathbb F}\xspace}
\newcommand{\Fstar}{\ensuremath{\mathbb F^*}\xspace}

\newcommand{\help}[1]{$#1$-helper\xspace}
\newcommand{\randompair}[1]{\ensuremath{\mathsf{randomPair}(#1)}\xspace}
\newcommand{\pair}[1]{$#1$-pair\xspace}
\newcommand{\pairs}[1]{$#1$-pairs\xspace}

\newcommand{\pairone}[1]{\G1-$#1$-pair\xspace}
\newcommand{\pairtwo}[1]{\G2-$#1$-pair\xspace}
\newcommand{\sameratio}[2]{\ensuremath{\mathsf{SameRatio}(#1,#2)}\xspace}
\newcommand{\vecc}[2]{\ensuremath{(#1)_{#2}}\xspace}
\newcommand{\players}{\ensuremath{[n]}\xspace}
\newcommand{\adv}{\ensuremath{\mathcal A}\xspace}
\newcommand{\advprime}{\ensuremath{{\mathcal A}'}\xspace}
\newcommand{\extprime}{\ensuremath{E'}\xspace}
\newcommand{\advrand}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
\num\newcommand{\srs1}{\ensuremath{\mathsf{srs_1}}\xspace}
\num\newcommand{\srs2}{\ensuremath{\mathsf{srs_2}}\xspace}
\num\newcommand{\srs0}{\ensuremath{\mathsf{srs}}\xspace}
\newcommand{\srsi}{\ensuremath{\mathsf{srs_i}}\xspace}
\newcommand{\com}{\ensuremath{\mathsf{com}}\xspace}
\newcommand{\comperm}{\ensuremath{\mathsf{com_{\sigma}}}\xspace}
\newcommand{\cm}{\ensuremath{\mathsf{cm}}\xspace}
\newcommand{\cmsig}{\ensuremath{\mathsf{cm_\sigma}}\xspace}
\newcommand{\open}{\ensuremath{\mathsf{open}}\xspace}
\newcommand{\openperm}{\ensuremath{\mathsf{open_{\sigma}}}\xspace}
\newcommand{\sigof}[1]{\ensuremath{\sigma(#1)}\xspace}
\newcommand{\proverexp}{\ensuremath{\mathsf{e}}\xspace}
\newcommand{\reducedelems}{\ensuremath{\mathsf{r}}\xspace}

\newcommand{\ci}{\ensuremath{\mathrm{CI}}\xspace}
\renewcommand{\deg}{\ensuremath{\mathrm{deg}}\xspace}
\newcommand{\pairvec}[1]{$#1$-vector\xspace}
\newcommand{\Fq}{\ensuremath{\mathbb{F}_q}\xspace}
\newcommand{\randpair}[1]{\ensuremath{\mathsf{rp}_{#1}}\xspace}
\newcommand{\randpairone}[1]{\ensuremath{\mathsf{rp}_{#1}^{1}}\xspace}
\newcommand{\abase}{\ensuremath{A_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\bbase}{\ensuremath{B_{\mathrm{\mathbf{0}}}}\xspace}
\newcommand{\cbase}{\ensuremath{C_{\mathrm{\mathbf{0}}}}\xspace}

\newcommand{\amid}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\bmid}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\cmid}{\ensuremath{C_{\mathrm{mid}}}\xspace}

\newcommand{\negl}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\randpairtwo}[1]{\ensuremath{\mathsf{rp_{#1}^2}}\xspace}%the randpair in G2
\newcommand{\nilp}{\ensuremath{\mathscr N}\xspace}
\newcommand{\groupgen}{\ensuremath{\mathscr G}\xspace}
\newcommand{\qap}{\ensuremath{\mathscr Q}\xspace}
\newcommand{\polprot}[4]{$(#1,#2,#3,#4)$-polynomial protocol}
\newcommand{\rangedprot}[5]{$#5$-ranged $(#1,#2,#3,#4)$-polynomial protocol}

\newcommand{\rej}{\ensuremath{\mathsf{rej}}\xspace}
\newcommand{\acc}{\ensuremath{\mathsf{acc}}\xspace}
\newcommand{\res}{\ensuremath{\mathsf{res}}\xspace}
\newcommand{\sha}[1]{\ensuremath{\mathsf{COMMIT}(#1)}\xspace}
 \newcommand{\shaa}{\ensuremath{\mathsf{COMMIT}}\xspace}
 \newcommand{\comm}[1]{\ensuremath{\mathsf{comm}_{#1}}\xspace}
 \newcommand{\defeq}{:=}

\newcommand{\B}{\ensuremath{\vec{B}}\xspace}
\newcommand{\dom}{\ensuremath{H}\xspace}
\newcommand{\C}{\ensuremath{\vec{C}}\xspace}
\newcommand{\Btwo}{\ensuremath{\vec{B_2}}\xspace}
\newcommand{\treevecsimp}{\ensuremath{(\tau,\rho_A,\rho_A \rho_B,\rho_A\alpha_A,\rho_A\rho_B\alpha_B, \rho_A\rho_B\alpha_C,\beta,\beta\gamma)}\xspace}% The sets of elements used in simplifed relation tree in main text body
\newcommand{\rcptc}{random-coefficient subprotocol\xspace}
\newcommand{\rcptcparams}[2]{\ensuremath{\mathrm{RCPC}(#1,#2)}\xspace}
\newcommand{\verifyrcptcparams}[2]{\ensuremath{\mathrm{\mathsf{verify}RCPC}(#1,#2)}\xspace}
\newcommand{\randadv}{\ensuremath{\mathsf{rand}_{\adv}}\xspace}
 \num\newcommand{\ex1}[1]{\ensuremath{ #1\cdot g_1}\xspace}
 \num\newcommand{\ex2}[1]{\ensuremath{#1\cdot g_2}\xspace}
 \newcommand{\pr}{\mathrm{Pr}}
 \newcommand{\powervec}[2]{\ensuremath{(1,#1,#1^{2},\ldots,#1^{#2})}\xspace}
 \newcommand{\partition}{\ensuremath{{\mathcal T}}\xspace}
 \newcommand{\partof}[1]{\ensuremath{{\partition_{#1}}}\xspace}
\num\newcommand{\out1}[1]{\ensuremath{\ex1{\powervec{#1}{d}}}\xspace}
\num\newcommand{\out2}[1]{\ensuremath{\ex2{\powervec{#1}{d}}}\xspace}
 \newcommand{\nizk}[2]{\ensuremath{\mathrm{NIZK}(#1,#2)}\xspace}% #2 is the hash concatenation input
 \newcommand{\verifynizk}[3]{\ensuremath{\mathrm{VERIFY\mhyphen NIZK}(#1,#2,#3)}\xspace}
\newcommand{\protver}{protocol verifier\xspace} 
\newcommand{\mulgroup}{\ensuremath{\F^*}\xspace}
\newcommand{\lag}[1]{\ensuremath{L_{#1}}\xspace} 
\newcommand{\sett}[2]{\ensuremath{\set{#1}_{#2}}\xspace}
\newcommand{\omegaprod}{\ensuremath{\alpha_{\omega}}\xspace}
\newcommand{\lagvec}[1]{\ensuremath{\mathrm{LAG}_{#1}}\xspace}
\newcommand{\trapdoor}{\ensuremath{r}}
\newcommand{\trapdoorext}{\ensuremath{r_{\mathrm{ext}}}\xspace}
\newcommand{\trapdoorsim}{\ensuremath{r_{\mathrm{sim}}}\xspace}
\renewcommand{\mod}{\ensuremath{\;\mathrm{mod}\;}}
\newcommand{\hsub}{\ensuremath{H^*}\xspace}
\num\newcommand{\enc1}[1]{\ensuremath{\left[#1\right]_1}\xspace}
\newcommand{\enci}[1]{\ensuremath{\left[#1\right]_i}\xspace}
\num\newcommand{\enc2}[1]{\ensuremath{\left[#1\right]_2}\xspace}
\newcommand{\gen}{\ensuremath{\mathsf{gen}}\xspace}
\newcommand{\prv}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\prvpoly}{\ensuremath{\prv}\xspace}
%{\ensuremath{\mathrm{P_{\mathsf{poly}}}}\xspace}
\newcommand{\prvpc}{\ensuremath{\mathrm{P_{\mathsf{PC}}}}\xspace}
\newcommand{\verpoly}{\ensuremath{\ver}\xspace}%\mathrm{V_{\mathsf{poly}}}}\xspace}
\newcommand{\verpc}{\ensuremath{\mathrm{V_{\mathsf{PC}}}}\xspace}
\newcommand{\ideal}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\prf}{\ensuremath{\pi}\xspace}
\newcommand{\simprv}{\ensuremath{\mathrm{P^{sim}}}\xspace}

%\newcommand{\enc}[1]{\ensuremath{\left[#1\right]}\xspace}
%\num\newcommand{\G0}{\ensuremath{\mathbf{G}}\xspace}
\newcommand{\GG}{\ensuremath{\mathbf{G^*}}\xspace}  % would have liked to call this G01 but problem with name
\num\newcommand{\g0}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\inst}{\ensuremath{\phi}\xspace}
\newcommand{\inp}{\ensuremath{\mathsf{x}}\xspace}
\newcommand{\wit}{\ensuremath{\omega}\xspace}
\newcommand{\ver}{\ensuremath{\mathsf{\mathbf{V}}}\xspace}
\newcommand{\per}{\ensuremath{\mathsf{\mathbf{P}}}\xspace}
\newcommand{\sonic}{\ensuremath{\mathsf{Sonic}}\xspace}
\newcommand{\aurora}{\ensuremath{\mathsf{Aurora}}\xspace}
\newcommand{\auroralight}{\ensuremath{\mathsf{Auroralight}}\xspace}
\newcommand{\groth}{\ensuremath{\mathsf{Groth'16}}\xspace}
\newcommand{\kate}{\ensuremath{\mathsf{KZG}}\xspace}
\newcommand{\rel}{\ensuremath{\mathcal{R}}\xspace}
\newcommand{\ext}{\ensuremath{E}\xspace}
\newcommand{\params}{\ensuremath{\mathsf{params}_{\inst}}\xspace}
\newcommand{\protparams}{\ensuremath{\mathsf{params}_{\inst}^\advv}\xspace}
\num\newcommand{\p1}{\ensuremath{P_1}\xspace}
\newcommand{\advv}{\ensuremath{ {\mathcal A}^{\mathbf{*}}}\xspace} % the adversary that uses protocol adversary as black box
\newcommand{\crs}{\ensuremath{\sigma}\xspace}
%\num\newcommand{\crs1}{\ensuremath{\mathrm{\sigma}_1}\xspace}
%\num\newcommand{\crs2}{\ensuremath{\mathrm{\sigma}_2}\xspace}
\newcommand{\set}[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand{\hgen}{\ensuremath{\mathbf{g}}\xspace}
\newcommand{\cosetgen}{\ensuremath{\mathbf{\kappa}}\xspace}
% \renewcommand{\sim}{\ensuremath{\mathsf{sim}}\xspace}%the distribution of messages when \advv simulates message of \p1
\newcommand{\real}{\ensuremath{\mathsf{real}}\xspace}%the distribution of messages when \p1 is honest and \adv controls rest of players
 \newcommand{\koevec}[2]{\ensuremath{(1,#1,\ldots,#1^{#2},\alpha,\alpha #1,\ldots,\alpha #1^{#2})}\xspace}
\newcommand{\mida}{\ensuremath{A_{\mathrm{mid}}}\xspace}
\newcommand{\midb}{\ensuremath{B_{\mathrm{mid}}}\xspace}
\newcommand{\midc}{\ensuremath{C_{\mathrm{mid}}}\xspace}
\newcommand{\chal}{\ensuremath{\mathsf{challenge}}\xspace}
\newcommand{\attackparams}{\ensuremath{\mathsf{params^{pin}}}\xspace}
\newcommand{\pk}{\ensuremath{\mathsf{pk}}\xspace}
\newcommand{\attackdist}[2]{\ensuremath{AD_{#1}}\xspace}
\renewcommand{\neg}{\ensuremath{\mathsf{negl}(\lambda)}\xspace}
\newcommand{\ro}{\ensuremath{{\mathcal R}}\xspace}
\newcommand{\elements}[1]{\ensuremath{\mathsf{elements}_{#1}}\xspace}
 \num\newcommand{\elmpowers1}[1]{\ensuremath{\mathrm{\mathsf{e}}^1_{#1}}\xspace}
 \num\newcommand{\elmpowers2}[1]{\ensuremath{\mathrm{\mathsf{e}}^2_{#1}}\xspace}
\newcommand{\elempowrs}[1]{\ensuremath{\mathsf{e}_{#1}}\xspace}
 \newcommand{\secrets}{\ensuremath{\mathsf{secrets}}\xspace}
 \newcommand{\polysofdeg}[1]{\ensuremath{\F_{< #1}[X]}\xspace}
 \newcommand{\polyss}{\ensuremath{\F[X]}\xspace}
 \newcommand{\bivar}[1]{\ensuremath{\F_{< #1}[X,Y]}\xspace}
 \newcommand{\sig}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\prot}{\ensuremath{\mathscr{P}}\xspace}
 \newcommand{\PCscheme}{\ensuremath{\mathscr{S}}\xspace}
 \newcommand{\protprime}{\ensuremath{\mathscr{P^*}}\xspace}
 \newcommand{\sigprv}{\ensuremath{\mathsf{P_{sc}}}\xspace}
 \newcommand{\sigver}{\ensuremath{\mathsf{V_{sc}}}\xspace}
 \newcommand{\sigpoly}{\ensuremath{\mathsf{S_{\sigma}}}\xspace}
 \newcommand{\idpoly}{\ensuremath{\mathsf{S_{ID}}}\xspace}
\newcommand{\idpolyevala}{\ensuremath{\mathsf{\bar{s}_{ID1}}}\xspace}
\newcommand{\sigpolyevala}{\ensuremath{\mathsf{\bar{s}_{\sigma1}}}\xspace}
\newcommand{\sigpolyevalb}{\ensuremath{\mathsf{\bar{s}_{\sigma2}}}\xspace}
\newcommand{\bctv}{\ensuremath{\mathsf{BCTV}}\xspace}
\newcommand{\PI}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\PIb}{\ensuremath{\mathsf{PI_B}}\xspace}
\newcommand{\PIc}{\ensuremath{\mathsf{PI_C}}\xspace}
\newcommand{\dl}[1]{\ensuremath{\widehat{#1}}\xspace}
\newcommand{\obgen}{\ensuremath{\mathcal O}\xspace}
\newcommand{\PC}{\ensuremath{\mathscr{P}}\xspace}
\newcommand{\permscheme}{\ensuremath{\sigma_\mathscr{P}}\xspace}
\newcommand{\aggdeg}[1]{\ensuremath{\mathfrak{d}(#1)}\xspace}

	
\newcommand{\selleft}{\ensuremath{\mathbf{q_L}}\xspace}
\newcommand{\selright}{\ensuremath{\mathbf{q_R}}\xspace}
\newcommand{\selout}{\ensuremath{\mathbf{q_O}}\xspace}
\newcommand{\selmult}{\ensuremath{\mathbf{q_M}}\xspace}
\newcommand{\selconst}{\ensuremath{\mathbf{q_C}}\xspace}
\newcommand{\selectors}{\ensuremath{\mathcal{Q}}\xspace}
\newcommand{\lvar}{\ensuremath{\mathbf{a}}\xspace}
\newcommand{\vars}{\ensuremath{\mathcal{V}}\xspace}
\newcommand{\rvar}{\ensuremath{\mathbf{b}}\xspace}
\newcommand{\ovar}{\ensuremath{\mathbf{c}}\xspace}
\newcommand{\pubvars}{\ensuremath{\mathcal{I}}\xspace}
\newcommand{\assignment}{\ensuremath{\mathbf{x}}\xspace}
\newcommand{\constsystem}{\ensuremath{\mathscr{C}}\xspace}
\newcommand{\relof}[1]{\ensuremath{\rel_{#1}}\xspace}
\newcommand{\pubinppoly}{\ensuremath{\mathsf{PI}}\xspace}
\newcommand{\sumi}[1]{\sum_{i\in[#1]}}
\newcommand{\summ}[1]{\sum_{i\in[#1]}}
\newcommand{\sumj}[1]{\sum_{j\in[#1]}}
\newcommand{\ZeroH}{\ensuremath{Z_{H}} \xspace}
\newcommand{\lpoly}{\ensuremath{\mathsf{a}}\xspace}
\newcommand{\rpoly}{\ensuremath{\mathsf{b}}\xspace}
\newcommand{\opoly}{\ensuremath{\mathsf{c}}\xspace}
\newcommand{\idpermpoly}{\ensuremath{\mathsf{z}}\xspace}
\newcommand{\lagrangepoly}{\ensuremath{\mathsf{L}}\xspace}
\newcommand{\zeropoly}{\ensuremath{\mathsf{\ZeroH}}\xspace}
\newcommand{\selmultpoly}{\ensuremath{\mathsf{q_M}}\xspace}
\newcommand{\selleftpoly}{\ensuremath{\mathsf{q_L}}\xspace}
\newcommand{\selrightpoly}{\ensuremath{\mathsf{q_R}}\xspace}
\newcommand{\seloutpoly}{\ensuremath{\mathsf{q_O}}\xspace}
\newcommand{\selconstpoly}{\ensuremath{\mathsf{q_C}}\xspace}
\newcommand{\idcomm}{\ensuremath{[s_{\mathsf{ID1}}]_1}\xspace}
\newcommand{\sigcomma}{\ensuremath{[s_{\mathsf{\sigma1}}]_1}\xspace}
\newcommand{\sigcommb}{\ensuremath{[s_{\mathsf{\sigma2}}]_1}\xspace}
\newcommand{\sigcommc}{\ensuremath{[s_{\mathsf{\sigma3}}]_1}\xspace}
\newcommand{\selleftcomm}{\ensuremath{[q_\mathsf{L}]_1}\xspace}
\newcommand{\selrightcomm}{\ensuremath{[q_\mathsf{R}]_1}\xspace}
\newcommand{\seloutcomm}{\ensuremath{[q_\mathsf{O}]_1}\xspace}
\newcommand{\selconstcomm}{\ensuremath{[q_\mathsf{C}]_1}\xspace}
\newcommand{\selmultcomm}{\ensuremath{[q_\mathsf{M}]_1}\xspace}

\newcommand{\multlinecomment}[1]{\directlua{-- #1}}
    

\newtheorem{lemma}{Lemma}[section]
\newtheorem{thm}[lemma]{Theorem}
\newtheorem{dfn}[lemma]{Definition}
\newtheorem{remark}[lemma]{Remark}

\newtheorem{claim}[lemma]{Claim}
\newtheorem{corollary}[lemma]{Corollary}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathcal{R}}
\newcommand{\crct}{\ensuremath{\mathsf{C}}\xspace}
\newcommand{\A}{\mathcal{A}}
%\newcommand{\G}{\mathcal{G}}
\newcommand{\Gr}{\mathbb{G}}
%\newcommand{\com}{\textsf{com}}  Ariel defined equivalent that also works in math mode
\newcommand{\cgen}{\text{cgen}}
\newcommand{\poly}{\ensuremath{\mathsf{poly(\lambda)}}\xspace}
\newcommand{\snark}{\ensuremath{\mathsf{snark(\lambda)}}\xspace}
\newcommand{\grandprod}{\mathsf{prod}}
\newcommand{\perm}{\mathsf{perm}}
%\newcommand{\open}{\mathsf{open}}
\newcommand{\update}{\mathsf{update}}
\newcommand{\Prove}{\mathcal{P}}
\newcommand{\Verify}{\mathcal{V}}
\newcommand{\Extract}{\mathcal{E}}
\newcommand{\Simulate}{\mathcal{S}}
\newcommand{\Unique}{\mathcal{U}}
\newcommand{\Rpoly}{\R{\poly}}
\newcommand{\Ppoly}{\Prove{\poly}}
\newcommand{\Vpoly}{\Verify{\poly}}
\newcommand{\Psnark}{\Prove{\snark}}
\newcommand{\Vsnark}{\Verify{\snark}}
\newcommand{\Rprod}{\R{\grandprod}}
\newcommand{\Pprod}{\Prove{\grandprod}}
\newcommand{\Vprod}{\Verify{\grandprod}}
\newcommand{\Rperm}{\R{\perm}}
\newcommand{\Pperm}{\Prove{\perm}}
\newcommand{\Vperm}{\Verify{\perm}}
% \newcommand{\zw}[1]{{\textcolor{magenta}{Zac:#1}}}
% \newcommand{\ag}[1]{{\textcolor{blue}{\emph{Ariel:#1}}}}
\newcommand{\prob}{\ensuremath{\mathrm{Pr}}\xspace}
\newcommand{\extprot}{\ensuremath{E_{\prot}}\xspace}
\newcommand{\extpc}{\ensuremath{E_{\PCscheme}}\xspace}
\newcommand{\advpc}{\ensuremath{\mathcal A_{\PCscheme}}\xspace}
\newcommand{\advprot}{\ensuremath{\mathcal A_{\prot}}\xspace}
\newcommand{\protmany}{\ensuremath{ {\prot}_k}\xspace}
\newcommand{\sone}{\ensuremath{ h_1}\xspace}
\newcommand{\stwo}{\ensuremath{ h_{2}}\xspace}
\newcommand{\X}{\ensuremath{ {\mathbf{x}}}\xspace}

\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\plonk}{\ensuremath{\mathtt{PLONK}}\xspace}
\newcommand{\marlin}{\ensuremath{\mathsf{Marlin}}\xspace}
\newcommand{\fractal}{\ensuremath{\mathsf{Fractal}}\xspace}
\newcommand{\Rsnark}{\R{\snark}}
\begin{document}
    \maketitle

    
    \begin{abstract}
     We present a protocol for checking the values of a committed polynomial $f\in \polysofdeg{n}$ over a multiplicative subgroup $H\subset \F$ of size $n$, are contained in the values of a table $t\in \F^d$. Our protocol can be viewed as a simplification of one from Bootle et. al \cite{arya} for a similar problem, with potential efficiency improvements when $d\leq n$. In particular, \cite{arya}'s protocol requires comitting to several auxiliary polynomials of degree $d\cdot \log n$, whereas ours requires three commitments to auxiliary polynomials of degree $n$, which can be much smaller in the case $d\sim n$.
     
     One common use case of this primitive in the zk-SNARK setting is a ``batched range proof'', where one wishes to check all of $f$'s values on $H$ are in a range $[0,\ldots,M]$. We present a slightly optimized protocol for this special case, and pose improving it as an open problem.
    \end{abstract}


\section{Introduction}
When wanting to use zk-SNARKs to prove statements involving standard primitives like AES-128 or SHA-256, one runs into the problem that the operations involved in these primitives are ``SNARK unfriendly'', in the sense of having large representations in the native SNARK language, which typically corresponds to low degree equations over a large prime field.
Examples of operations with large overhead, are ones involving bit decomposition like bitwise XOR or AND. This has lead to growing research into STARK and SNARK friendly hash functions and symmetric primitives that are based solely on native field operations \cite{poseidon,marvelous,mimc,mimc2}.


We investigate an alternative approach, where for commonly used operations we precompute a lookup table of the legitimate (input, output) combinations; and the prover argues the witness values exist in this table.

In polynomial language, this ultimately boils down to proving polynomials are the same ``up to multiplicities''.
That is, suppose that the values in the lookup table are \sett{t_i}{i\in [d]} and the values in the witness are \sett{f_i}{i\in [n]}. We want to show that the polynomials
\[F(X)\defeq \prod_{i\in [n]} (X-f_i), G(X)\defeq \prod_{i\in [d]}(X-t_i)\]
have the same roots, ignoring multiplicites; i.e. that for some non-negative integers \sett{e_i}{i\in [d]} we  have
$F(X) = \prod_{i\in [d]} (X-t_i)^{e_i}$.
Bootle et. al \cite{arya} gave an algorithm for this exact problem, also in the context of efficient SNARK arithmetization of a common operation (in their case, repeatedly checking that field elements correspond to certain convenient sparse representations of boolean strings).

Their algorithm requires committing to a vector of length $d\log n$ that contains
for each $i\in [d], j\in [\log n] $ the value $(x-t_i)^{2^j}$ for a random verifier challenge $x\in\F$.
They also commit to the binary decomposition of the \set{e_i},
and using the two, prove that $F$ is of the desired form.

We present here an arguably simpler protocol for the same problem, that doesn't require explicitly representing the multiplicities. Let us use the notation
$f\subset t$ as shorthand for $\sett{f_i}{i\in [n]}\subset \sett{t_i}{i\in [d]}$.

The idea is to look at a sorted version \set{s_i} of the values \set{f_i},
and compare the set of non-zero \emph{differences} in \set{s_i}
and \set{t_i}. Note that if $f\subset t$, and every element of $t$ appears at least once in $f$, we indeed have that these sets of differences are the same. However, the converse is not true: We can create a sequence of values \set{s_i}
having the same difference set as \set{t_i}, but with the differences appearing in \emph{different order}; and in this case we won't have $s\subset t$.
As an illustrating example, take
\[t=\set{1,4,8}, s = \set{1,1,4,8,8,8}, s' = \set{1,5,5,5,8,8}\]
All three sets have the same difference set \set{3,4}; but since those differences appear in different order in $s'$ and $t$, we don't have $s'\subset t$. Though not an issue in the above examples, we also didn't address checking the starting point is the same in $s$ and $t$.
Both issues can be solved by comparing \emph{randomized} difference sets:
We choose random $\beta \in \F$, and compare the elements in the sequences 
\sett{t_i+\beta t_{i+1}}{i\in [d-1]}, \sett{s_i +\beta s_{i+1}}{i\in [n-1]}.


Seemingly, we have taken ``one step forward and one back'' by adding the random $\beta$, as now pairs $(s_i,s_{i+1})$ with $s_i=s_{i+1}$ will give a non-zero contribution $s_i+\beta \cdot s_{i+1} = (1+\beta)\cdot s_i$. However, all elements corresponding to a repetition are now multiples of $(1+\beta)$ and we are able to use this to ``identify'' them and not use them in the comparison with the table.
Specifically, we show that this check can be done correctly and efficiently using a ``grand product argument'' similar to the one used in \cite{plonk}'s permutation argument.


A technicality is that as mentioned this approach assumes all of $t$'s values appear at least once in $f$; which is one reason we in fact take $s$ to be the sorted version of the \emph{concatenation} of $f$ and $t$. This ends up also helping to batch both checks into one product: The check that $f\subset s$, and the check that $s\subset t$.


Precise details of the scheme are given in Section \ref{sec:mainscheme}.

\section{Preliminaries}
\paragraph{Terminology}
For integer $d$, we denote by \polysofdeg{d} the set of univariate polynomials over \F of degree smaller than $d$.
\paragraph{Polynomial Protocols}
We use the ranged polynomial protocol terminology from \cite{plonk} to describe our protocols. We repeat the definition for reference.

In such a protocol a prover \prv sends polynomials of a certain degree bound $d$ to an ideal party \ideal, and at the end of protocol, the verifier can ask whether certain identities hold between the polynomials sent during the protocol, the input polynomials, and the preprocessed polynomials, on a predefined set $H$.

More precisely,
\begin{dfn}\label{dfn:polyprotocol}
Fix positive integers $d,D,t,\ell$ and $H\subset \F$.
An $H$-ranged \emph{$(d,D,t,\ell)$-polynomial protocol} is a multiround protocol between a prover \prvpoly, verifier 
\verpoly and trusted party \ideal that proceeds as follows.

\begin{enumerate}
\item The protocol definition includes a set of \emph{preprocessed and input polynomials} $g_1,\ldots,g_\ell \in \polysofdeg{d}$.

\item The messages of \prvpoly are sent to \ideal and are of the form $f$ for $f\in \polysofdeg{d}$. If \prvpoly sends a message not of this form, the protocol is aborted.
 
 
\item The messages of  \verpoly to \prvpoly are arbitrary (but we will concentrate on public coin protocols where the messages are simply random coins).


 \item At the end of the protocol, suppose $f_1,\ldots,f_t$ are the polynomials that were sent from \prvpoly to \ideal. \verpoly may ask \ideal if certain polynomial identities holds \emph{on $H$} between \set{f_1,\ldots,f_t,g_1,\ldots,g_\ell}.
 Where each identity is of the form
 \[F(X)\defeq G(X, h_1(v_1(X)),\ldots,h_M(v_M(X)))\equiv 0,\]
 for some $h_i\in  \set{f_1,\ldots,f_t,g_1,\ldots,g_\ell}$, $G\in \F[X,X_1,\ldots,X_{M}]$, $v_1,\ldots,v_{M} \in \polysofdeg{d}$
 such that $F\in \polysofdeg{D}$ for every choice of $f_1,\ldots,f_t$ made by \prvpoly when following the protocol correctly.
 
 
 
 \item After receiving the answers from \ideal regarding the identities, \verpoly outputs \acc if all identities hold, and outputs \rej otherwise.

\end{enumerate}
 \end{dfn}
It is shown in Section 4 of \cite{plonk} how such a protocol can be compiled into one in the algebraic group model using the polynomial commitment scheme of \cite{kate}.


For such a protocol \prot, let $\aggdeg{\prot}$ be the maximum over $f_1,\ldots,f_t$ sent by an honest prover during protocol execution of $\left(\sum_{i\in [t]} \deg(f_i)+1\right)+D-|H|$.

The prover complexity ends up being closely tied to \aggdeg{\prot} as this corresponds to the number of group operations to commit to all polynomials (including the quotient polynomial that comes up in translating a ranged polynomial protocol to a polynomial protocol) using \cite{kate}. We will thus attempt to minimize \aggdeg{\prot} in our protocols.

 
 \paragraph{Lagrange bases and multiplicative subgroups}
 In our protocols, we take $H$ to be a multiplicative subgroup of some order $N$ with generator \hgen.
 For $i\in [N]$, we denote by $L_i\in \polysofdeg{N}$ the $i$'th Lagrange polynomial for $H$, that satisfies $L_i(\hgen^i)=1$ and $L_i(\hgen^j)=0$ for $j\neq i$.
 These polynomials are covenient when specifying a point check in an $H$-ranged protocol.
 For example, requiring $L_i(\X)f(\X)=0$ for all $\X\in H$ is equivalent to 
 $f(\hgen^i)=0$.
 
 The generator \hgen is convenient for specifying constraints on ``neighboring values''.
 For example, the constraint 
 $f(\hgen\cdot \X)- f(\X) =1$
 means that $f$'s value grows by one when going to the ``next'' point.
 




We refer the reader to Section 4 of \cite{plonk} for more details.
 

\section{The main scheme}\label{sec:mainscheme}


\paragraph{Notation:}

Fix integers $n,d$ and vectors $f\in \F^n, t\in\F^d$.
We use the notation $f\subset t$ to mean $\sett{f_i}{i\in [n]}\subset \sett{t_i}{i\in [d]}$. Let $\dom=\set{\hgen,\ldots,\hgen^{n+1}=1}$ be a multiplicative subgroup of order $n+1$ in \F.
%Denote by $\cosetgen$ be an element of a non-trivial coset of $H$ in $\F^*$.
For a polynomial $f\in \polyss$ and $i\in [n+1]$ we sometimes denote $f_i\defeq f(\hgen^i)$.
For a vector $f\in \F^n$, we also denote by $f$ the polynomial in \polysofdeg{n} with $f(\hgen^i) =f_i$.


When $f\subset t$ , we say that $f$ is \emph{sorted by $t$} when values appear in the same order in $f$ as they do in $t$. Formally, for any $i<i'\in [n]$ such that $f_i\neq f_{i'}$, if $j,j'\in [d]$ are such that $t_{j} = f_i, t_{j'} =f_{i'}$ then $j<j'$.

Now, given $t\in \F^d, f\in \F^n, s\in \F^{n+d}$, define bi-variate polynomials $F,G$ as 
\[F(\beta,\gamma) \defeq (1+\beta)^n\cdot \prod_{i\in [n]} (\gamma + f_i) \prod_{i\in [d-1]} (\gamma(1+\beta) + t_i + \beta t_{i+1})\]
                                  
\[G(\beta,\gamma) \defeq \prod_{i\in [n+d-1]} \left( \gamma(1+\beta) + s_i + \beta s_{i+1} \right)\]
we have
\begin{claim}\label{clm:main_lookup}

 $F\equiv G$ if and only if 
 \begin{enumerate}
  \item $f \subset t$, and 
  \item $s$ is $(f,t)$ sorted by $t$. 
 \end{enumerate}

\end{claim}
\begin{proof}
 We write $F,G$ as elements of $\F(\beta)[\gamma]$ while taking out a $(1+\beta)$ factor as follows.
\[F(\beta,\gamma) = (1+\beta)^{n+d-1}\cdot \prod_{i\in [n]} (\gamma + f_i) \prod_{i\in [d-1]} \left(\gamma + (t_i + \beta t_{i+1})/(1+\beta)\right)\]
                                  
\[G(\beta,\gamma)  = (1+\beta)^{n+d-1} \prod_{i\in [n+d-1]} \left( \gamma+ (s_i + \beta s_{i+1})/(1+\beta) \right)\]
 
 
 Suppose first that $f\subset t$ and $s\in \F^{n+d}$ is $(f,t)$ sorted by $t$.

 Then for each $j\in [d-1]$, there is a distinct index $i\in [n+d-1]$ such that
 $ (t_j,t_{j+1})=(s_i,s_{i+1})$.
 The corresponding factors in $F,G$ are equal. That is,
 \[(\gamma + (t_j + \beta t_{j+1})/(1+\beta)) \equiv (\gamma + (s_i + \beta s_{i+1})/(1+\beta))\]

 Let $P'\subset [n+d-1]$ the set of these $d-1$ indices $i$
 , and let $P\defeq [n+d-1]\setminus P'$.
 The $n$ indices $i\in P$ are such 
 that $s_i=s_{i+1}$, and  $\sett{s_i}{i\in P}$ equals $\sett{f_i}{i\in [n]}$ as multisets.
 That is, we have a one-to-one map $j:P\to [n]$ such that for each $i\in P$, $s_i = f_{j(i)}$.
 For each $i\in P$, the corresponding factor of $G$, will be
 \[ \gamma + (s_i + \beta s_{i+1})/(1+\beta)= \gamma + s_i,\]
 which equals the factor $\gamma + f_{j(i)}$ in $F$.
 
 
 For the other direction, assume $F\equiv G$ as polynomials in $\F[\beta,\gamma]$.  
 Then $F\equiv G$ also as elements of $\F(\beta)[\gamma]$.
 Since $\F(\beta)[\gamma]$ is a unique factorization domain, we know that the linear factors of $F,G$, as written above must be equal.
 Thus, for each $i\in [d-1]$, $G$ must have a factor equal to $(\gamma + (t_i + \beta t_{i+1})/(1+\beta))$.
 In other words, for some $j\in [n+d-1]$, 
 \[\gamma + (t_i + \beta t_{i+1})/(1+\beta)= \gamma+ (s_j + \beta s_{j+1})/(1+\beta),\]
 which implies $t_i + \beta t_{i+1}= s_j + \beta s_{j+1}$, and therefore $t_i= s_j, t_{i+1}=s_{j+1}$.
Call $P'\subset [n+d-1]$ the set of these $d-1$ indices $j$.
 For any index $j\in [n+d-1]\setminus P'$, there must be a factor ``coming from $f$'' in $F$ that equals the corresponding factor in $G$. More precisely, for such $j$ there exists $i\in [n]$ such that
 \[\gamma + f_i = \gamma+ (s_j + \beta s_{j+1})/(1+\beta),\]
 or equivalently
 \[f_i+ \beta f_i = s_j + \beta s_{j+1}\]
 which implies
 $f_i= s_j=s_{j+1}$.
 
 Thus, we know that whenever consecutive values in $s$ are different, they are exactly equal to two consecutive values in $t$, and all values of $f$ are values of $t$.
 
 \end{proof}
 
 Claim \ref{clm:main_lookup} motivates the following protocol. 
It will be convenient to assume $d=n+1$. (If $d\leq n$ pad $t$ with $n-d+1$ repetitions of the last element.)
 \paragraph{Preprocessed polynomials:}
The polynomial $t \in \polysofdeg{n+1}$  describing the lookup values.


\paragraph{Inputs: $f\in \polysofdeg{n}$}
\paragraph{Protocol:}
\begin{enumerate}
 \item Let $s\in \F^{2n+1}$ be the vector that is $(f,t)$ sorted by $t$. We represent $s$ by $\sone,\stwo \in \polysofdeg{n+1}$ as follows.
%  the following polynomial in $\polysofdeg{2n+2}$ that represents $s$ on $\dom \cup \cosetgen \dom$:
$\sone (\hgen^i) = s_i$ for $i\in [n+1]$; and $\stwo(\hgen ^i)= s_{n+i}$ for each $i\in [n+1]$.
 
 \item \prvpoly computes the polynomials $\sone,\stwo$ and sends them to the ideal party \ideal.
 \item \verpoly chooses random $\beta,\gamma \in \F$ and sends them to \prvpoly.
 \item \prvpoly computes a polynomial $Z\in \polysofdeg{n+1}$ that aggregates the value $F(\beta,\gamma)/G(\beta,\gamma)$ where $F,G$ are as described above. Specifically, we let
\begin{enumerate}
 \item  $Z(\hgen) = 1$,
\item For $2\leq i \leq n$
% \[Z(\hgen^i)=(1+\beta)^{i-1}\prod_{1\leq j<i} (\gamma + f(\hgen^j))/(\gamma(1+\beta) + s(\hgen^j) + \beta s(\hgen^{j+1})),\] 
% \item For $1\leq i \leq n+1$,
\[Z(\hgen^{i})= \frac{(1+\beta)^{i-1} \prod_{j < i} (\gamma + f_j)\cdot \prod_{1\leq j < i} (\gamma(1+\beta)+ t_j + \beta t_{j+1})}{\prod_{1\leq j <i} (\gamma(1+\beta)+ s_j + \beta s_{j+1})(\gamma(1+\beta)+ s_{n+j} + \beta s_{n+j+1})},\]
 and
\item $Z(\hgen^{n+1})=1$.
\end{enumerate}
 \item \prvpoly sends $Z$ to \ideal.
 \item \verpoly checks that $Z$ is indeed of the form described above, and that $Z(\hgen^{n+1})=1$. More precisely, \verpoly checks the following identities for all $\X\in H$.
 \begin{enumerate}
  \item $L_1(\X)(Z(\X)-1)= 0$.
  \item 
  \[Z(\X)(1+\beta)\cdot (\gamma + f(\X))(\gamma(1+\beta)+ t(\X)+\beta t(\hgen \cdot \X) )\]
  \[= Z(\hgen\cdot \X)(\gamma(1+\beta)+ \sone(\X)+\beta \sone(\hgen \cdot \X))(\gamma(1+\beta)+ \stwo(\X)+\beta \stwo(\hgen \cdot \X))\]
  \item\label{check:consist} $L_{n+1}(\X)(\sone(\X)-\stwo(\hgen \cdot \X))= 0$.
%   \item $Z(\cosetgen\cdot  \X)(\gamma(1+\beta)+ t(\X)+\beta t(\X\cdot \hgen) )=Z(\cosetgen\hgen \cdot  \X)(\gamma(1+\beta)+ s(\cosetgen \X)+\beta s(\cosetgen \X\cdot \hgen) )$.
  \item $L_{n+1}(\X)(Z(\X)-1)= 0$.
 
 \end{enumerate}

%  \begin{enumerate}
%   \item $L_1(a) (Z(a)-1) =0$.
%   \item $Z(a)f'(a) = g'(a)Z(a\cdot \hgen)$.
%  \end{enumerate}
 and outputs \acc iff all checks hold.
\end{enumerate}
\begin{lemma}\label{lem:lookupprot}
 Suppose that $\sett{f(\hgen^i)}{i\in [n]}$ is not contained in  \sett{t(\hgen^i)}{i\in [n+1]}.
 Then for any strategy of \adv playing the role of \prvpoly in the above protocol \prot, the probability that
 \verpoly accepts is \negl.
 Furthermore, we have $\aggdeg{\prot} = 5n+4$.
\end{lemma}
\begin{proof}
We start by computing $\aggdeg{\prot}$.
The prover sends $\sone,\stwo,Z\in \polysofdeg{n+1}$,
which aggregates to $3n+3$. The second identity checked by the verifier is of the highest degree, containing a product of these three and the linear term $X-\hgen^{n+1}$,
which gives us another $3n+2$ from which we subtract $|H|=n+1$.
In total we get $5n+4$.

We proceed to prove correctness. The check in step \ref{check:consist} shows that $\sone(\hgen^{n+1})=\stwo(\hgen)$, and thus $\sone,\stwo$ indeed consistently describe a single vector $s\in \F^{2n+1}$.
Using Claim \ref{clm:main_lookup} we know that when $f$'s range is not contained in $t$'s for any choice of $s$ sent by \prvpoly the polynomials $F(X,Y), G(X,Y)$ are different.
 From the SZ lemma e.w.p \negl \verpoly chooses $\beta,\gamma$ such that $F(\beta,\gamma)\neq G(\beta,\gamma)$. In this case we have $Z(\hgen^{n+1})\neq 1$ which means \verpoly rejects.
\end{proof}

\section{Generalizing to vector lookups and multiple tables}
Suppose we have several witness polynomials $f_1,\ldots,f_w \in \polysofdeg{n}$,
and a table of values $t^*\in (\F^w)^d$. 
We wish to check that for each $j\in [n]$
$(f_1(\hgen^j),\ldots,f_w(\hgen^j))\in t^*$.
We can use randomization to efficiently reduce to the case of Section \ref{sec:mainscheme}.

For each $i\in [w]$ we will include in the set of preprocessed polynomials $t_i \in \polysofdeg{d}$ with $t_i(\hgen^j) = t^*_{i,j}$ for each $j\in [d]$.

The verifier will choose random $\alpha \in \F$.

Then we will define $t\defeq \sum_{i\in [w]} \alpha^i t_i, f \defeq \sum_{i\in [w]} \alpha^i f_i$.

Assume that for some $j\in [n]$, $(f_1(\hgen^j),\ldots,f_w(\hgen^j))\notin t^*$.
Then e.w.p $d\cdot w/|\F|$, $f(\hgen^j)\notin t$.
Thus, after the selection of $\alpha$,
we can run the protocol of the previous section on $f,t$.

As alluded to in the introduction, a natural use case for this vector lookup primitive is a key-value setting, where we have a function $f$ with $w-1$ inputs,
and wish to verify a vector is of the form $(x_1,\ldots,x_{w-1},f(x_1,\ldots,x_{w-1}))$ for some input $(x_1,\ldots,x_{w-1})$.

\subsection{Multiple tables}
Suppose further that we have in fact have multiple tables $t^*_1,\ldots, t^*_\ell$
and for each $i\in [n]$ wish to check that for some predefined $j=j(i)\in [\ell]$  $(f_1(\hgen^i),\ldots,f_w(\hgen^i))\in t^*_j$ .
We can reduce to the previous setting as follows.
We create a preprocessed table containing $t^*_1,\ldots, t^*_\ell$ as sub-tables, by adding a column specifying the table index.

That is, suppose for simplicity that for each $j\in [\ell]$, $t^*_j\in (\F^{w})^{d/\ell}$.
We construct $t^*\in (\F^{w+1})^d$, 
containing for each $j\in [\ell], i\in [d/\ell]$ of the element
$(j,(t^*_j)_i)$.
We preprocess a polynomial $q\in \polysofdeg{n}$
such that $q_i =j(i)$, where again $j(i)$ is the subtable we wish the $i$'th value to be in.
Now apply the method above to check that for each $i\in [n]$,
$(q(\hgen^i),f_1(\hgen^i),\ldots,f_w(\hgen^i))\in t^*$

\section{An optimized solution for continuous ranges}\label{sec:ranges}
Suppose we wish to check that $f \subset \set{0,\ldots,d-1}$ for some integer $d< n$.
We could use our above protocol while setting $t_i = i-1$ for $i\in [d]$.
By using $d=n+1$, the above protocol allows us to check $f\subset \set{0,\ldots,n}$ with complexity $\aggdeg{\prot}=5n+4$ as stated in Lemma \ref{lem:lookupprot}. 
We present an alternative protocol with the same complexity that will allow us to check $f\subset \set{0,\ldots,2n-2}$.
%almost exactly the same complexity ($5n+5$ instead of $5n+4$).
In fact, the protocol naturally generalizes for ranges $\set{0,\ldots,c(n-1)}$ while only increasing the degree of verifier constraints. Thus, one may choose a larger $c$ in protocols where the range proof is a subroutine, according to the maximal constraint degree in other parts of the protocol.


The idea is the following. (We emphasize we are assuming the range is in fact contained in \F, i.e. $cn < |\F|$.)
Suppose that we enforce that the sorted witness $s$ starts from zero and ends at $c\cdot (n-1)$, i.e. $s_1=0$, $s_{2n+1} = c\cdot (n-1)$, and that for each $i\in [2n]$, $s_{i+1}-s_i \leq c$.
This sufficies to deduce that $s_i \in \set{0,\ldots,c(n-1)}$ for each $i\in [2n+1]$.

The condition $s_{i+1}-s_i \leq c$ can be enforced by a constraint that plugs in this difference into the degree $c+1$ polynomial that vanishes on \set{0,\ldots,c}. Enforcing the increments this way obviates the need to look at a permutation between differences, and instead we can directly check a permutation between the values of $(f,t)$ and $s$; where $t$ is the table of $c$'th multiples, i.e. $t_i = c\cdot (i-1)$ for $i\in [n]$.

We proceed to describe the protocol in detail.
As in the first protocol, we assume $H$ is a multiplicative subgroup of order $n+1$ with generator \hgen.

The protocol is parameterized by a positive integer parameter $c$.
And we denote by $P$ the polynomial
$P(X)\defeq \prod_{i= 0}^c(X-i)$.
\paragraph{Preprocessed polynomials:}
The polynomial $t \in \polysofdeg{n}$  with $t_i = c\cdot (i-1)$ for $i\in [n]$.

\paragraph{Inputs: $f\in \polysofdeg{n}$}
\paragraph{Protocol:}
\begin{enumerate}
 \item Let $s\in \F^{2n+1}$ be the vector that is $(f,t)$ sorted by $t$. We represent $s$ by $\sone,\stwo \in \polysofdeg{n+1}$ as follows.
%  the following polynomial in $\polysofdeg{2n+2}$ that represents $s$ on $\dom \cup \cosetgen \dom$:
$\sone (\hgen^i) = s_i$ for $i\in [n+1]$; and $\stwo(\hgen ^i)= s_{n+i}$ for each $i\in [n]$ and $\stwo(\hgen^{n+1})=c(n-1)$.
 
 \item \prvpoly computes the polynomials $\sone,\stwo$ and sends them to the ideal party \ideal.
 \item \verpoly chooses random $\gamma \in \F$ and sends it to \prvpoly.
 \item \prvpoly computes a polynomial $Z\in \polysofdeg{n+1}$ that aggregates the value $F(\beta,\gamma)/G(\beta,\gamma)$ where $F,G$ are as described above. Specifically, we let
\begin{enumerate}
 \item  $Z(\hgen) = 1$,
\item For $2\leq i \leq n$
% \[Z(\hgen^i)=(1+\beta)^{i-1}\prod_{1\leq j<i} (\gamma + f(\hgen^j))/(\gamma(1+\beta) + s(\hgen^j) + \beta s(\hgen^{j+1})),\] 
% \item For $1\leq i \leq n+1$,
\[Z(\hgen^{i})= \frac{\prod_{j < i} (\gamma + f_j)\cdot \prod_{1\leq j < i} (\gamma+ t_j)}{\prod_{1\leq j <i} (\gamma + s_j)(\gamma+ s_{n+j})},\]
 and
\item $Z(\hgen^{n+1})=1$.
\end{enumerate}
 \item \prvpoly sends $Z$ to \ideal.
 \item  \verpoly checks the following identities for all $\X \in H$.
 \begin{enumerate}
\item \label{step:rangefirst} $L_1(\X)(\sone(\X)) = 0$.
\item$P\left(\sone(\hgen\cdot \X)- \sone(\X)\right)= 0$.
\item $P\left(\stwo(\hgen\cdot  \X)- \stwo(\X)\right)= 0$.
  \item\label{check:consisttwo} $L_{n+1}(\X)(\sone(\X)-\stwo(\hgen\cdot \X ))= 0$
\item \label{step:rangefirstlast}$L_{n+1}(\X)(\stwo(\X)) = c\cdot n$.
  \item \label{step:rangepermfirst}$L_1(\X)(Z(\X)-1)= 0$.
  \item 
  \[(\X-\hgen^{n+1}) (Z(\X) (\gamma + f(\X))(\gamma+ t(\X))= (\X-\hgen^{n+1})\cdot  Z(\hgen \cdot \X)(\gamma+ \sone(\X))(\gamma+ \stwo(\X))) \]
%   \item $Z(\cosetgen\cdot  \X)(\gamma(1+\beta)+ t(\X)+\beta t(\X\cdot \hgen) )=Z(\cosetgen\hgen \cdot  \X)(\gamma(1+\beta)+ s(\cosetgen \X)+\beta s(\cosetgen \X\cdot \hgen) )$.

\item \label{step:rangepermlast}$L_{n+1}(\X)(Z(\X)-1)\equiv 0$.
 
 \end{enumerate}

%  \begin{enumerate}
%   \item $L_1(a) (Z(a)-1) =0$.
%   \item $Z(a)f'(a) = g'(a)Z(a\cdot \hgen)$.
%  \end{enumerate}
 and outputs \acc iff all checks hold.
\end{enumerate}
\begin{remark}
 Note that if we are in a situation where the sorted values of $f$ alone already have a consecutive gap of at most $c$, we can use a simpler protocol showing a permutation between $f$ and $s$ without needing to use $t$.
\end{remark}



\begin{lemma}\label{lem:rangeprot}
Fix positive integer $c$.
 Suppose that $\sett{f(\hgen^i)}{i\in [n]}$ is not contained in  \sett{0,\ldots,c(n-1)}.
 Then for any strategy of \adv playing the role of \prvpoly in the above protocol \prot, the probability that \verpoly accepts is \negl.
 Furthermore, for $c\geq 2$ we have $\aggdeg{\prot} = (3+c)n+2$.
\end{lemma}


\begin{proof}
 We compute \aggdeg{\prot}:
 As in the previous protocol \prv sends $Z,\sone,\stwo \in \polysofdeg{n+1}$,
 which aggregates to $3n+3$.
 Now, for $c\geq 2$ the highest degree constraints are the check
 $P\left(\sone(\hgen\cdot X)- \sone(X)\right)\equiv 0$ (and the same check for \stwo).
 Which gives degree $(c+1)\cdot n$ to which we add one and subtract $|H|=n+1$;
 totalling in $3n+3+(c+1)\cdot n - (n+1) = (3+c)n+2$.
 
 Now for the main claim, assume that for some $i\in [n]$, $f_i \notin \set{0,\ldots,cn}$.
 The checks in steps \ref{step:rangefirst}-\ref{step:rangefirstlast} imply 
 that the values \sett{\sone(\hgen^i),\stwo(\hgen^i)}{i\in [n]} are all in the range \set{0,\ldots, c(n-1)}.
 Define polynomials 
 \[F(X) \defeq \prod_{i\in [n]} (X-f(\hgen^i))(X-t(\hgen^i)),
 G(X) \defeq \prod_{i\in [n]} (X-\sone(\hgen^i))(X-\stwo(\hgen^i)))
 \]
Under the assumption that for some $i\in [n]$, $f_i \notin \set{0,\ldots,cn}$,
we have that $F$ and $G$ are distinct polynomials.

The checks in steps \ref{step:rangepermfirst}-\ref{step:rangepermlast} imply
that $F(\gamma) = G(\gamma)$.

Since $\gamma \in \F$ is chosen uniformly it follows that \verpoly accepts with probability \negl.
 
 \end{proof}

 
 
 

\section*{Acknowledgements} 
We thank Jens Groth for introducing us to the lookup protocol of \cite{arya}.
We thank Kevaundray Wedderburn for comments and corrections and the name plookup.
% 
% Let us measure the cost of this in terms of auxiliary polynomials given.
% \prv would need to send the sorted polynomial $s\in \polysofdeg{n+d}$.
% And the preprocessing would require computing $t\in \polysofdeg{d}$.
% This would start being prohibitively expensive e.g. for $d=2^{32}$.
% 
% For such large $d$, one solution would be to split each value of $f$ into two values in the range $\set{0,\ldots, \sqrt d}$. And then check the values are in this smaller range.
% This will double the size of $f$ to $2n$, and require $s\in \polysofdeg{2n+\sqrt{d}}$.
% 
% We propose an alternative solution where we remain with $f\in \polysofdeg{n}$
% and require two auxiliary polynomials $s,s'\in \polysofdeg{n}$
\bibliographystyle{alpha}
\bibliography{references}
   \end{document}








% 
% We can use a reduced form of PLONK's permutation argument, to validate that two polynomials share the same roots. This in turn can be used to verify two polynomials share the same Lagrange coefficients. 
% 
% For two degree-n polynomials $A(X) = \sum_{i=1}^n a_iL_i(X), B(X) = \sum_{i=1}^n b_iL_i(X)$. Using a random challenge $\gamma \in \F_p$, we can verify that the two sets $\{a_1, \ldots, a_n \}, \{b_1, \ldots, b_n\}$ are identical:
% 
% $$ \prod_{i=1}^n \frac{(a_i + \gamma)}{(b_i + \gamma)} = 1$$
% 
% In addition, we can validate the correctness of subsets within larger sets. For $l$ subsets, we introduce a new challenge $\beta$ and two selector polynomials $q_1(X) = \sum_{i=1}^n \sigma_{1}(i)L_i(X), q_2(X) = \sum_{i=1}^n \sigma_{2}(i)L_i(X)$, where both $\sigma_{1}(i)$ and $\sigma_2(i)$ evaluate on $H$ to $l$ unique values. The modified permutation argument becomes
% 
% $$
% \prod_{i=1}^n \frac{(a_i + \sigma_1(i)\beta + \gamma)}{(b_i + \sigma_2(i)\beta + \gamma)} = 1
% $$
% 
% \section{Implementing arbitrary lookup tables}
% 
% Consider a PLONK circuit with a program width of $m$ and a depth of $n$. We can represent witnesses to the circuit's memory cells via $w_i$ for all $i \in [1, \ldots, mn]$.
% \\
% \\
% We wish to prove that a subset of memory cells are copies of elements in a size $k$ precomputed lookup table. We represent table values via $t_i$ for all $i \in [1, \ldots, k]$.
% \\
% \\
% To ensure that all polynomial identities are evaluated modulo the vanishing polynomial of a size-$n$ multiplicative subgroup $H$, we can split the lookup table into size-$n$ subsets. i.e. our PLONK circuit now has a \textit{table} width of $v$, where $vn >= k$.
% \\
% \\
% To validate a sequence of lookups, the high level outline is as follows
% 
% \begin{enumerate}
% 	\item create a key/value mapping that maps an index in the lookup table to a value
% 	\item apply the key/value mapping to the table reads in program memory
% 	\item isolate \textit{unique} table reads in program memory
% 	\item isolate values from the lookup table $t$ that were copied into program memory
% 	\item validate a subset permutation on the set of unique table reads and the set of used table lookup values
% \end{enumerate}
% 
% \section{Using randomized constraints for key/value mappings}
% 
% We can use randomized constraints to create key/value mappings for arbitrary combinations of keys and values. This is useful for situations where a key and a value require more values than the set of integers $[1, \ldots, p]$, where $p$ is the order of the circuit's native field arithmetic.
% \\
% \\
% After committing to program memory values, the verifier generates a random challenge $\alpha$ and sends it to the prover. We can discriminate between $l$ distinct lookup tables using the $l$'th powers of $\alpha$.
% \\
% \\
% The prover can now commit to a sorted list of table reads. We can define the number of table reads as $e = s n$, where $s <= w$. The set of table reads is represented via $\{ r_1, \ldots, r_e \}$, where each table read is a linear combination of two memory cells $w_1, w_2$, where $r = w_1 + \alpha w_2$. The specific mapping between memory cells and table read elements is described using $l$ randomized constraints, represented by identities $E_1, \ldots, E_l$.
% \\
% \\
% We can now validate a permutation between the set of all table reads $$r_1, \ldots, r_e$$, and the set of values produced by applying $$E_1, \ldots, E_l$$ to every row in program memory.
% \\
% \\
% \textit{example: XOR gates, width-4 circuit}. Consider the scenario where we wish to evaluate $a ^ b = c$, where $a, b, c$ are in the range $[0, \ldots, 255]$. All possible XOR combinations can be represented by $2^16$ values in a lookup table. For a row $i$ of program memory, the XOR constraint is
% $$
% E_1(\{w_{(i-1)m + 1}, \ldots, w_{im} \}) = w_{(i-1)m + 1} + 2^8 w_{(i-1)m + 2} + \alpha w_{(i-1)m + 3} + \beta + \gamma
% $$
% 
% where $w_{(i-1)m + 1} = a$, $w_{(i-1)m + 2} = b$, $w_{(i-1)m + 3} = c$. Instead of directly mapping memory cells to values in $r_1, \ldots, r_e$, we map the output of the identities $E_1, \ldots, E_l$ to values in $r_1, \ldots, r_e$ instead.
% \\
% \\
% We can use selector polynomials to toggle our randomized constraints on/off for a given row in program memory. This allows us to also mask out locations in program memory that are not table reads when required.
% \\
% \\
% To validate the correctness of the values $\{ r_1, \ldots, r_e \}$, we validate that the following permutation holds:
% 
% $$
% \frac{\prod_{i=1}^n (\sum_{j=1}^l E_j(\{ w_{(i-1)m + 1}, \ldots, w_{im}\}))}
% {\prod_{i=1}^n \prod_{j=1}^s (r_{(i-1)s + j} + q_{(i-1)s + j}\beta + \gamma)}
% $$
% 
% We can assume that, for any given $i \in [1, \ldots, n]$, only one randomized constraint will be active, which ensures that we are still evaluating a 'grand product'.
% \\
% \\
% When the circuit is constructed, the number of table reads per sub-table will be known, which means that we can use a precomputed selector $q$ to map each element of $\{r_1, \ldots, r_n \}$ to their respective sub-table.
% \\
% \\
% Finally, we should note that each identity can map more than one cell in program memory into the lookup read table. For example, we could index a range table using the following constraint:
% $$
% E_{range} = (w_1 + \beta^{range} + \gamma)(w_2 + \beta^{range} + \gamma)(w_3 + \beta^{range} + \gamma)
% $$
% 
% Because we have introduced a selector polynomial to toggle each constraint, each identity can only contain (for a width 4 program) cubic terms, without increasing the degree of PLONK's quotient polynomial $T(X)$.
% 
% \section{From a sorted list to a lookup argument}
% 
% We are now at the stage where we can validate that all of a program's table reads have been mapped into the set of values $R = \{ r_1, \ldots, r_e \}$, split over $s$ degree-$n$ commitments.
% \\
% \\
% We now need to provide the prover with a mechanism to remove duplicate elements. We can assume that the elements of $R$ are sorted in monotonically increasing order (for each subset). If this is not the case, our final permutation argument will be rejected by the verifier.
% \\
% \\
% We introduce $s$ \textbf{mask} commitments, that contain elements $\{ m_1, \ldots, m_e \}$. Where all elements take boolean values. N.B. there seems like there should be a way to not need this mask thingy, but it's extremely cheap to commit to using a Lagrange-base SRS.
% \\
% \\
% For a given mask element, if $m_i = 1$, the prover is making a claim that two adjacent values in $R$ are adjacent.
% \\
% \\
% The verifier validate this by evaluating the following:
% $$
% m_i^2 - m_i = 0
% $$
% 
% $$
% (r_{i-1} - r_i)m_i = 0
% $$
% 
% The latter identity always holds if $m_i = 0$. If $m_i = 1$, then $r_{i-1} = r_i$.
% \\
% \\
% Note that this does not prevent the prover from \textit{not} masking duplicates. This is not necessary because the final permutation argument will fail if duplicates have not been removed.
% 
% \section{The final permutation check}
% 
% We almost have a complete lookup argument. The final step is the validate that elements $\{r_1m_1, \ldots, r_em_e \}$ is a \textit{subset} of the lookup table values $\{ t_1, \ldots, t_k \}$.
% \\
% \\
% We need to accommodate for situations where not all table elements have been read from in a given proof - a strict permutation won't suffice.
% \\
% \\
% To this end, we introduce a second set of $l$ masking polynomials $y_1(X), \ldots, y_l(X)$, containing elements $y_1, \ldots, y_k$.
% \\
% \\
% We use a transition constraint to validate that
% $$
% y_i^2 - y_i = 0
% $$
% We represent our lookup table via $l$ commitments to table keys, $\{tk_1(X), \ldots, tk_l(X)\}$, $l$ commitments to table values $\{ tv_1(X), \ldots, tv_l(X) \}$ and $l$ commitments to subtable indices $\{ts_1(X), \ldots, ts_l(X) \}$.
% \\
% \\
% The final permutation check is the following:
% 
% $$
% \frac{
% \prod_{i=1}^n \prod_{j=1}^l \bigg( y_{(i-1)l + j}(tk_{(i-1)l + j} + \alpha tv_{(i-1)l + j} + \beta ts_{(i-1)l + j} + \gamma) + (1 - y_{(i-1)l + j}) \bigg)
% }
% {
% {\prod_{i=1}^n \prod_{j=1}^s\bigg( (1 - m_{(i-1)s + j})(r_{(i-1)s + j} + q_{(i-1)s + j}\beta + \gamma) + m_{(i-1)s + j} \bigg)}
% }
% $$
% 
% \section{Efficiency Analysis}
% 
% Adding this lookup argument into PLONK incurs the following fixed overheads for the prover:
% 
% \begin{enumerate}
% 	\item Two new grand product polynomials, to validate the two permutations (TODO: can these be combined somehow without exploding T(X)?)
% 	\item A commitment to $M(X)$
% 	\item A commitment to $Y(X)$
% \end{enumerate}
% 
% Assuming these are committed to using a Lagrange-base SRS, the number of scalar multiplications will be equal to the number of reads, for the grand product polynomials. Both $M(X)$ and $Y(X)$ can be committed to using group additions instead of group exponentiations, so their overall contribution to prover time is small.
% \\
% \\
% We can also generously assume that less than $1/4$ of all memory cells will be table reads. This sets $s = 1$. Similarly, we can likely assume that the set of all lookup table values will be less than $n$, which sets $l = 1$.
% \\
% \\
% The final number of group exponentiations required by the prover for each table read is $3$ - one to commit to $R(X)$, one for each new grand product polynomial.
% 
% \section{Examples: XOR}
% 
% We can perform a 32-bit XOR in 4 gates (using an 8bit xor and not the funky sparse bit trick), using a lookup table and one randomized constraint.
% 
% $$
% \begin{array}{cccc}
% a_0 & b_0 & c_0 & --- \\
% a_1 & b_1 & c_1 & --- \\
% a_2 & b_2 & c_2 & --- \\
% a_3 & b_3 & c_3 & --- \\
% \end{array}
% $$
% 
% With the above structure, we can ensure that all of $a_i, b_i, c_i$ track accumulating sums instead of raw 8-bit values - the randomized constraint can extract the 8-bit slices from the differences between elements. This means we don't have to swap between 8-bit representations and native representations of 32 bit integers, which makes it much easier to combine different arithmetic operations.
% 
% Total cost is 4 gates and 4 table reads. The 4 reads contribute 12 scalar multiplications. A gate's base 'cost' is 11 scalar multiplications, making the 32-bit XOR cost approximately 5 gates.
% \\
% \\
% The current best case is the quaternary XOR custom gate, which requires 17 gates. This yields a >3x speed increase.
% 
% \subsection{example: bit rotations on 32 bit integers}
% 
% Assume we have a 32-bit unsigned integer, represented using 1 memory cell with value $a$. We wish to evaluate a bit rotation by a fixed number of bits. E.g. $a >>> 5$.
% \\
% \\
% Any rotation by an odd number of bits will 'slice' one 16-bit value in two. In this case into a 11-bit value $b_0$, a 16-bit value $b_1$ and a 5-bit value $b_2$. i.e.
% 
% $$a >>> 5 = b_0 + 2^{16 - 5}b_1 + 2^{32 - 5}b_2$$
% 
% We can now validate the following:
% 
% $b =  b_0 + 2^{16 - 5}b_1 + 2^{32 - 5}b_2$
% $a = b_2 + 2^5b_0 + 2^16b_1$
% 
% This requires 3 table lookups, $b_0$ must come from an 11-bit range, $b_1$ from a 16-bit range, $b_2$ from a 5-bit range. Both of above conditions can be verified using a single gate (but would require the ability to validate 2 arithmetic statements per gate. Otherwise 2 gates).
% \\
% \\
% Total cost is 1 gate and 3 reads, which is ~2 native gates.
% 
% \subsection{example: unsigned addition}
% 
% Let's say we wish to evaluate $a + b = c$. Instead of using a basic add gate, we can use a lookup to ensure that $c$ is within the range $[0, \ldots, 2^{32}]$. Specifically we validate:
% 
% $$a + b = c_0 + 2^{16}c_1 + 2^{32}c_2$$
% 
% We use a simple transition constraint to validate that $c_2 \in [0, 1]$. We use lookup table reads to validate that $c_0$ and $c_1$ are 16-bit values.
% \\
% \\
% Like in the XOR and bit rotation case, we can represent $c$ via accumulating sums in program memory, instead of raw 16-bit slices.
% \\
% \\
% Total cost is 1 gate and 2 reads.
% 
% \subsection{example: Blake2s}
% 
% The Blake2s round function applies the following operation to three 32-bit variables $a, b, c$, where $d$ is a constant rotation value:
% 
% $$
% e = (a + b) ^ c >>> d
% $$
% 
% By combining the above three sub-programs, we can evaluate this 'add xor rotate' operation in 4 gates and 4 table reads!
% \\
% \\
% Layout in program memory is the following:
% $$
% \begin{array}{|c|c|c|c|}
% (a+b)_0 & c_0 & e_0 & --- \\
% (a+b)_1 & c_1 & e_1 & b \\
% (a+b)_2 & c_2 & e_2 & (b + overflow) \\
% (a+b)_3 & c_3 & e_3 & a \\
% \end{array}
% $$
% 
% Step 1: all values `a+b`, `c`, `e` track accumulating sums. So ${(a+b)}_3 = a + b \text{ mod } 2^{32}$.
% \\
% Step 2: we use a lookup table that combines an XOR with a bit rotation, instead of performing these in discrete steps.
% \\
% Step 3: use a transition constraint that validates
% $$
% {a+b}_3 = a + {b + overflow}
% $$
% \\
% Step 4: use a transition constraint that validates 
% $$
% ({b + overflow} - b)^2 - ({b + overlow} - b) = 0
% $$
% 
% A Blake2s round consists of 4 of these, which is 16 gates and 16 table reads. 
% \\
% \\
% The blake2s hash function requires 80 applications of this round function, which would be 1,280 gates and 1,280 table reads. The table reads would cost ~3,840 scalar multiplications, which is equivalent to ~350 native gates. So the total cost would be $\approx1,650$ 'gates'. Current best estimate with quaternary decomposition constraints is $\approx6,700$. R1CS requires $>20,000$.
% 

